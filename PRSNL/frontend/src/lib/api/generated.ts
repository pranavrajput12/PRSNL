/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * PRSNL
 * OpenAPI spec version: 0.1.0
 */
import { createMutation, createQuery } from '@tanstack/svelte-query';
import type {
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from '@tanstack/svelte-query';

import type {
  AnalyzeContentApiAiAnalyzePost200,
  AnalyzeContentApiAiAnalyzePostParams,
  AnalyzeImageApiVisionAnalyzePost200,
  AnalyzeImageApiVisionAnalyzePostParams,
  AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams,
  BatchIngestionRequest,
  BatchProcessVideosApiVideoStreamingBatchProcessPostParams,
  BatchScrapeApiFirecrawlBatchScrapePost200,
  BatchScrapeApiFirecrawlBatchScrapePostParams,
  BatchScrapingRequest,
  BatchSummarizeApiBatchPostParams,
  BatchSummaryRequest,
  BodyAnalyzeImageApiVisionAnalyzePost,
  BodyImportBookmarksApiImportBookmarksPost,
  BodyImportJsonApiImportJsonPost,
  BodyImportNotesApiImportNotesPost,
  BodyIngestFileApiRagIngestFilePost,
  BodyProcessScreenshotApiVisionScreenshotPost,
  BodyUploadFileApiFileUploadPost,
  BulkCategorizationResponse,
  BulkCategorizeApiCategorizeBulkPostParams,
  BulkURLRequest,
  CaptureRequest,
  CategorizationRequest,
  CategorizationResponse,
  CheckDuplicateRequest,
  CheckDuplicateResponse,
  CheckVideoUrlApiVideoStreamingCheckUrlGetParams,
  CodeSnippet,
  ContentAnalysisRequest,
  CrawlWebsiteApiFirecrawlCrawlPost200,
  CrawlWebsiteApiFirecrawlCrawlPostParams,
  CrawlingRequest,
  CreateMiniCourseApiVideoStreamingMiniCoursePostParams,
  CreateMiniCourseRequest,
  CreateTestItemApiAdminTestCreateItemPost200,
  CustomSummaryRequest,
  DebugItemsApiAdminDebugItemsGet200,
  DeleteDocumentApiRagDocumentsDocumentIdDelete200,
  DeleteDocumentApiRagDocumentsDocumentIdDeleteParams,
  DetailedHealthApiHealthDetailedGet200,
  DevelopmentCategory,
  DevelopmentItem,
  DevelopmentStats,
  DigestRequest,
  DocumentIngestionRequest,
  DocumentUpdateRequest,
  DownloadVideoApiVideosVideoIdDownloadPost200,
  DuplicateCheckRequest,
  DuplicateCheckResponse,
  DuplicateGroup,
  DuplicateSearchRequest,
  EnhancedSearchApiSearchPost200,
  EnhancedSearchApiSearchPostParams,
  ExportKnowledgeBaseApiRagExportGet200,
  ExportKnowledgeBaseApiRagExportGetParams,
  ExtractStructuredDataApiFirecrawlExtractPost200,
  ExtractStructuredDataApiFirecrawlExtractPostParams,
  FileProcessingStatus,
  FileUploadResponse,
  FindAllDuplicatesApiDuplicatesFindAllGetParams,
  FindDuplicatesApiSearchDuplicatesPost200,
  FindDuplicatesApiSearchDuplicatesPostParams,
  FindRelatedRequest,
  FindRelatedVideosApiVideoStreamingRelatedPostParams,
  FindSimilarItemsApiSearchSimilarItemIdGetParams,
  FindSimilarItemsApiSearchSimilarPost200,
  FindSimilarItemsApiSearchSimilarPostParams,
  GenerateCustomSummaryApiCustomPostParams,
  GenerateDigestApiDigestPostParams,
  GenerateSummaryApiAiSummaryPost200,
  GenerateSummaryApiAiSummaryPostParams,
  GenerateTagsApiAiTagsPostParams,
  GenerateTopicSummaryApiTopicPostParams,
  GetAllRoutesApiDebugRoutesGet200,
  GetAvailableModelsApiAiModelsGet200,
  GetAvailableModelsApiAiModelsGetParams,
  GetContentTrendsApiAnalyticsTrendsGetParams,
  GetContentTypeApiContentTypesTypeNameGet200,
  GetContentTypesApiContentTypesGet200,
  GetCrawlStatusApiFirecrawlJobJobIdGet200,
  GetCrawlStatusApiFirecrawlJobJobIdGetParams,
  GetDashboardInsightsApiInsightsDashboardGetParams,
  GetDevelopmentDocsApiDevelopmentDocsGetParams,
  GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetParams,
  GetInsightsApiInsightsGetParams,
  GetItemConnectionsApiItemsItemIdConnectionsGetParams,
  GetItemProcessingStatusApiDebugItemProcessingItemIdGet200,
  GetLearningVelocityApiInsightsLearningVelocityGetParams,
  GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetParams,
  GetRagStatsApiRagStatsGet200,
  GetRagStatsApiRagStatsGetParams,
  GetRecentItemsApiDebugRecentItemsGet200,
  GetRecentItemsApiDebugRecentItemsGetParams,
  GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetParams,
  GetSearchStatsApiSearchStatsGet200,
  GetSearchStatsApiSearchStatsGetParams,
  GetServiceStatusApiFirecrawlStatusGet200,
  GetServiceStatusApiFirecrawlStatusGetParams,
  GetStorageStatsApiAdminStorageStatsGet200,
  GetTimelineApiTimelineGetParams,
  GetTimelineTrendsApiInsightsTimelineTrendsGetParams,
  GetTopContentApiInsightsTopContentGetParams,
  GetTopTagsApiInsightsTopTagsGetParams,
  GetTopicClusteringApiAnalyticsTopicsGetParams,
  GetTrendingInsightsApiInsightsTrendingGetParams,
  GetValidationStatusApiAiValidationStatusGet200,
  GetValidationStatusApiAiValidationStatusGetParams,
  GetVideoStatsApiVideoStreamingStatsGetParams,
  GetVideoTimelineApiVideoStreamingTimelineGetParams,
  GetVisionStatusApiVisionStatusGet200,
  HTTPValidationError,
  HealthCheckApiHealthGet200,
  HybridSearchApiRagSearchHybridPost200,
  HybridSearchApiRagSearchHybridPostParams,
  HybridSearchRequest,
  IngestBatchApiRagIngestBatchPost200,
  IngestBatchApiRagIngestBatchPostParams,
  IngestDocumentApiRagIngestPost200,
  IngestDocumentApiRagIngestPostParams,
  IngestFileApiRagIngestFilePost200,
  IngestFileApiRagIngestFilePostParams,
  InsightTypeInfo,
  InsightsResponse,
  Item,
  ItemConnectionResponse,
  ItemCreate,
  ItemSummaryRequest,
  ItemUpdate,
  KeywordSearchGetApiSearchKeywordGet200,
  KeywordSearchGetApiSearchKeywordGetParams,
  ListItemsApiV2ItemsGetParams,
  LivenessProbeApiHealthLiveGet200,
  MergeDuplicatesRequest,
  MergeDuplicatesResponse,
  MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost200,
  MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams,
  PreviewDigestApiDigestPreviewGetParams,
  ProcessScreenshotApiVisionScreenshotPost200,
  ProcessScreenshotApiVisionScreenshotPostParams,
  ProcessVideoApiVideoStreamingProcessPostParams,
  ProcessVideoRequest,
  QueryRagApiRagQueryPost200,
  QueryRagApiRagQueryPostParams,
  RAGQueryRequest,
  ReadinessProbeApiHealthReadyGet200,
  RequestVideoTranscodeApiVideosVideoIdTranscodePost200,
  RequestVideoTranscodeApiVideosVideoIdTranscodePostParams,
  RunOrphanedCleanupApiAdminCleanupOrphanedPost200,
  RunTempCleanupApiAdminCleanupTempPost200,
  RunTempCleanupApiAdminCleanupTempPostParams,
  ScrapeUrlApiFirecrawlScrapePost200,
  ScrapeUrlApiFirecrawlScrapePostParams,
  ScrapingRequest,
  SearchItemsApiSearchGetParams,
  SearchRequest,
  SemanticSearchApiSearchSemanticPostParams,
  SemanticSearchGetApiSearchSemanticGet200,
  SemanticSearchGetApiSearchSemanticGetParams,
  SemanticSearchQuery,
  SimilarItemsRequest,
  StructuredExtractionRequest,
  SuggestQuestionsApiSuggestQuestionsGetParams,
  SuggestQuestionsV1ApiV1SuggestQuestionsGetParams,
  SuggestionRequest,
  SuggestionResponse,
  SummarizeItemApiItemPostParams,
  SummaryGenerationRequest,
  SummaryResponse,
  Tag,
  TagGenerationRequest,
  TimelineResponse,
  TopicSummaryRequest,
  TranscribeAudioApiAiTranscribePost200,
  TranscribeAudioApiAiTranscribePostParams,
  TranscriptionRequest,
  UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPost200,
  UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams,
  UpdateDocumentApiRagDocumentsDocumentIdPut200,
  UpdateDocumentApiRagDocumentsDocumentIdPutParams,
  VideoInDB,
  VideoResponse,
} from '../types/generated';

import { customInstance } from './mutator';

/**
 * Debug endpoint to test if routes work
 * @summary Debug Capture
 */
export const debugCaptureApiCaptureDebugGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/capture/debug`, method: 'GET', signal });
};

export const getDebugCaptureApiCaptureDebugGetQueryKey = () => {
  return [`/api/capture/debug`] as const;
};

export const getDebugCaptureApiCaptureDebugGetQueryOptions = <
  TData = Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDebugCaptureApiCaptureDebugGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>> = ({
    signal,
  }) => debugCaptureApiCaptureDebugGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DebugCaptureApiCaptureDebugGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>
>;
export type DebugCaptureApiCaptureDebugGetQueryError = unknown;

/**
 * @summary Debug Capture
 */

export function createDebugCaptureApiCaptureDebugGet<
  TData = Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof debugCaptureApiCaptureDebugGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDebugCaptureApiCaptureDebugGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Simple test route to verify routing works
 * @summary Test Capture
 */
export const testCaptureApiCaptureTestPost = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/capture/test`, method: 'POST', signal });
};

export const getTestCaptureApiCaptureTestPostMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof testCaptureApiCaptureTestPost>>,
    TError,
    void,
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof testCaptureApiCaptureTestPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['testCaptureApiCaptureTestPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof testCaptureApiCaptureTestPost>>,
    void
  > = () => {
    return testCaptureApiCaptureTestPost();
  };

  return { mutationFn, ...mutationOptions };
};

export type TestCaptureApiCaptureTestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof testCaptureApiCaptureTestPost>>
>;

export type TestCaptureApiCaptureTestPostMutationError = unknown;

/**
 * @summary Test Capture
 */
export const createTestCaptureApiCaptureTestPost = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof testCaptureApiCaptureTestPost>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof testCaptureApiCaptureTestPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getTestCaptureApiCaptureTestPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Minimal smoke test with direct DB insert
 * @summary Ping Capture
 */
export const pingCaptureApiCapturePingPost = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/capture/ping`, method: 'POST', signal });
};

export const getPingCaptureApiCapturePingPostMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof pingCaptureApiCapturePingPost>>,
    TError,
    void,
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof pingCaptureApiCapturePingPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['pingCaptureApiCapturePingPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pingCaptureApiCapturePingPost>>,
    void
  > = () => {
    return pingCaptureApiCapturePingPost();
  };

  return { mutationFn, ...mutationOptions };
};

export type PingCaptureApiCapturePingPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof pingCaptureApiCapturePingPost>>
>;

export type PingCaptureApiCapturePingPostMutationError = unknown;

/**
 * @summary Ping Capture
 */
export const createPingCaptureApiCapturePingPost = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof pingCaptureApiCapturePingPost>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof pingCaptureApiCapturePingPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPingCaptureApiCapturePingPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Test database connection separately
 * @summary Test Database
 */
export const testDatabaseApiCaptureTestDbGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/capture/test-db`, method: 'GET', signal });
};

export const getTestDatabaseApiCaptureTestDbGetQueryKey = () => {
  return [`/api/capture/test-db`] as const;
};

export const getTestDatabaseApiCaptureTestDbGetQueryOptions = <
  TData = Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTestDatabaseApiCaptureTestDbGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>> = ({
    signal,
  }) => testDatabaseApiCaptureTestDbGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TestDatabaseApiCaptureTestDbGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>
>;
export type TestDatabaseApiCaptureTestDbGetQueryError = unknown;

/**
 * @summary Test Database
 */

export function createTestDatabaseApiCaptureTestDbGet<
  TData = Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof testDatabaseApiCaptureTestDbGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTestDatabaseApiCaptureTestDbGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Capture a new item (web page, note, file, etc.).
 * @summary Capture Item
 */
export const captureItemApiCapturePost = (captureRequest: CaptureRequest, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/api/capture`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: captureRequest,
    signal,
  });
};

export const getCaptureItemApiCapturePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof captureItemApiCapturePost>>,
    TError,
    { data: CaptureRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof captureItemApiCapturePost>>,
  TError,
  { data: CaptureRequest },
  TContext
> => {
  const mutationKey = ['captureItemApiCapturePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof captureItemApiCapturePost>>,
    { data: CaptureRequest }
  > = (props) => {
    const { data } = props ?? {};

    return captureItemApiCapturePost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CaptureItemApiCapturePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof captureItemApiCapturePost>>
>;
export type CaptureItemApiCapturePostMutationBody = CaptureRequest;
export type CaptureItemApiCapturePostMutationError = HTTPValidationError;

/**
 * @summary Capture Item
 */
export const createCaptureItemApiCapturePost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof captureItemApiCapturePost>>,
      TError,
      { data: CaptureRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof captureItemApiCapturePost>>,
  TError,
  { data: CaptureRequest },
  TContext
> => {
  const mutationOptions = getCaptureItemApiCapturePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Check if a URL already exists in the knowledge base before capture.
 * @summary Check Duplicate Url
 */
export const checkDuplicateUrlApiCaptureCheckDuplicatePost = (
  checkDuplicateRequest: CheckDuplicateRequest,
  signal?: AbortSignal
) => {
  return customInstance<CheckDuplicateResponse>({
    url: `/api/capture/check-duplicate`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: checkDuplicateRequest,
    signal,
  });
};

export const getCheckDuplicateUrlApiCaptureCheckDuplicatePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof checkDuplicateUrlApiCaptureCheckDuplicatePost>>,
    TError,
    { data: CheckDuplicateRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof checkDuplicateUrlApiCaptureCheckDuplicatePost>>,
  TError,
  { data: CheckDuplicateRequest },
  TContext
> => {
  const mutationKey = ['checkDuplicateUrlApiCaptureCheckDuplicatePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkDuplicateUrlApiCaptureCheckDuplicatePost>>,
    { data: CheckDuplicateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return checkDuplicateUrlApiCaptureCheckDuplicatePost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckDuplicateUrlApiCaptureCheckDuplicatePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkDuplicateUrlApiCaptureCheckDuplicatePost>>
>;
export type CheckDuplicateUrlApiCaptureCheckDuplicatePostMutationBody = CheckDuplicateRequest;
export type CheckDuplicateUrlApiCaptureCheckDuplicatePostMutationError = HTTPValidationError;

/**
 * @summary Check Duplicate Url
 */
export const createCheckDuplicateUrlApiCaptureCheckDuplicatePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof checkDuplicateUrlApiCaptureCheckDuplicatePost>>,
      TError,
      { data: CheckDuplicateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof checkDuplicateUrlApiCaptureCheckDuplicatePost>>,
  TError,
  { data: CheckDuplicateRequest },
  TContext
> => {
  const mutationOptions = getCheckDuplicateUrlApiCaptureCheckDuplicatePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Search for items by keyword or phrase.
 * @summary Search Items
 */
export const searchItemsApiSearchGet = (
  params: SearchItemsApiSearchGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/search`, method: 'GET', params, signal });
};

export const getSearchItemsApiSearchGetQueryKey = (params: SearchItemsApiSearchGetParams) => {
  return [`/api/search`, ...(params ? [params] : [])] as const;
};

export const getSearchItemsApiSearchGetQueryOptions = <
  TData = Awaited<ReturnType<typeof searchItemsApiSearchGet>>,
  TError = HTTPValidationError,
>(
  params: SearchItemsApiSearchGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof searchItemsApiSearchGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchItemsApiSearchGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchItemsApiSearchGet>>> = ({
    signal,
  }) => searchItemsApiSearchGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof searchItemsApiSearchGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchItemsApiSearchGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchItemsApiSearchGet>>
>;
export type SearchItemsApiSearchGetQueryError = HTTPValidationError;

/**
 * @summary Search Items
 */

export function createSearchItemsApiSearchGet<
  TData = Awaited<ReturnType<typeof searchItemsApiSearchGet>>,
  TError = HTTPValidationError,
>(
  params: SearchItemsApiSearchGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof searchItemsApiSearchGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchItemsApiSearchGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Find items similar to the given item using embeddings
 * @summary Find Similar Items
 */
export const findSimilarItemsApiSearchSimilarItemIdGet = (
  itemId: string,
  params?: FindSimilarItemsApiSearchSimilarItemIdGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/search/similar/${itemId}`,
    method: 'GET',
    params,
    signal,
  });
};

export const getFindSimilarItemsApiSearchSimilarItemIdGetQueryKey = (
  itemId: string,
  params?: FindSimilarItemsApiSearchSimilarItemIdGetParams
) => {
  return [`/api/search/similar/${itemId}`, ...(params ? [params] : [])] as const;
};

export const getFindSimilarItemsApiSearchSimilarItemIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  params?: FindSimilarItemsApiSearchSimilarItemIdGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindSimilarItemsApiSearchSimilarItemIdGetQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>
  > = ({ signal }) => findSimilarItemsApiSearchSimilarItemIdGet(itemId, params, signal);

  return { queryKey, queryFn, enabled: !!itemId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindSimilarItemsApiSearchSimilarItemIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>
>;
export type FindSimilarItemsApiSearchSimilarItemIdGetQueryError = HTTPValidationError;

/**
 * @summary Find Similar Items
 */

export function createFindSimilarItemsApiSearchSimilarItemIdGet<
  TData = Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  params?: FindSimilarItemsApiSearchSimilarItemIdGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarItemIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindSimilarItemsApiSearchSimilarItemIdGetQueryOptions(
    itemId,
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Search using semantic similarity
 * @summary Semantic Search
 */
export const semanticSearchApiSearchSemanticPost = (
  semanticSearchQuery: SemanticSearchQuery,
  params?: SemanticSearchApiSearchSemanticPostParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/search/semantic`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: semanticSearchQuery,
    params,
    signal,
  });
};

export const getSemanticSearchApiSearchSemanticPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof semanticSearchApiSearchSemanticPost>>,
    TError,
    { data: SemanticSearchQuery; params?: SemanticSearchApiSearchSemanticPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof semanticSearchApiSearchSemanticPost>>,
  TError,
  { data: SemanticSearchQuery; params?: SemanticSearchApiSearchSemanticPostParams },
  TContext
> => {
  const mutationKey = ['semanticSearchApiSearchSemanticPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof semanticSearchApiSearchSemanticPost>>,
    { data: SemanticSearchQuery; params?: SemanticSearchApiSearchSemanticPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return semanticSearchApiSearchSemanticPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type SemanticSearchApiSearchSemanticPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof semanticSearchApiSearchSemanticPost>>
>;
export type SemanticSearchApiSearchSemanticPostMutationBody = SemanticSearchQuery;
export type SemanticSearchApiSearchSemanticPostMutationError = HTTPValidationError;

/**
 * @summary Semantic Search
 */
export const createSemanticSearchApiSearchSemanticPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof semanticSearchApiSearchSemanticPost>>,
      TError,
      { data: SemanticSearchQuery; params?: SemanticSearchApiSearchSemanticPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof semanticSearchApiSearchSemanticPost>>,
  TError,
  { data: SemanticSearchQuery; params?: SemanticSearchApiSearchSemanticPostParams },
  TContext
> => {
  const mutationOptions = getSemanticSearchApiSearchSemanticPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * GET endpoint for semantic search (convenience method).
 * @summary Semantic Search Get
 */
export const semanticSearchGetApiSearchSemanticGet = (
  params: SemanticSearchGetApiSearchSemanticGetParams,
  signal?: AbortSignal
) => {
  return customInstance<SemanticSearchGetApiSearchSemanticGet200>({
    url: `/api/search/semantic`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSemanticSearchGetApiSearchSemanticGetQueryKey = (
  params: SemanticSearchGetApiSearchSemanticGetParams
) => {
  return [`/api/search/semantic`, ...(params ? [params] : [])] as const;
};

export const getSemanticSearchGetApiSearchSemanticGetQueryOptions = <
  TData = Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>,
  TError = HTTPValidationError,
>(
  params: SemanticSearchGetApiSearchSemanticGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSemanticSearchGetApiSearchSemanticGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>
  > = ({ signal }) => semanticSearchGetApiSearchSemanticGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SemanticSearchGetApiSearchSemanticGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>
>;
export type SemanticSearchGetApiSearchSemanticGetQueryError = HTTPValidationError;

/**
 * @summary Semantic Search Get
 */

export function createSemanticSearchGetApiSearchSemanticGet<
  TData = Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>,
  TError = HTTPValidationError,
>(
  params: SemanticSearchGetApiSearchSemanticGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof semanticSearchGetApiSearchSemanticGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSemanticSearchGetApiSearchSemanticGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a chronological list of captured items using cursor-based pagination.
 * @summary Get Timeline
 */
export const getTimelineApiTimelineGet = (
  params?: GetTimelineApiTimelineGetParams,
  signal?: AbortSignal
) => {
  return customInstance<TimelineResponse>({ url: `/api/timeline`, method: 'GET', params, signal });
};

export const getGetTimelineApiTimelineGetQueryKey = (params?: GetTimelineApiTimelineGetParams) => {
  return [`/api/timeline`, ...(params ? [params] : [])] as const;
};

export const getGetTimelineApiTimelineGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimelineApiTimelineGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTimelineApiTimelineGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getTimelineApiTimelineGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimelineApiTimelineGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineApiTimelineGet>>> = ({
    signal,
  }) => getTimelineApiTimelineGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTimelineApiTimelineGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineApiTimelineGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimelineApiTimelineGet>>
>;
export type GetTimelineApiTimelineGetQueryError = HTTPValidationError;

/**
 * @summary Get Timeline
 */

export function createGetTimelineApiTimelineGet<
  TData = Awaited<ReturnType<typeof getTimelineApiTimelineGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTimelineApiTimelineGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getTimelineApiTimelineGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTimelineApiTimelineGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve details of a specific item by ID.
 * @summary Get Item Detail
 */
export const getItemDetailApiItemsItemIdGet = (itemId: string, signal?: AbortSignal) => {
  return customInstance<Item>({ url: `/api/items/${itemId}`, method: 'GET', signal });
};

export const getGetItemDetailApiItemsItemIdGetQueryKey = (itemId: string) => {
  return [`/api/items/${itemId}`] as const;
};

export const getGetItemDetailApiItemsItemIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemDetailApiItemsItemIdGetQueryKey(itemId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>> = ({
    signal,
  }) => getItemDetailApiItemsItemIdGet(itemId, signal);

  return { queryKey, queryFn, enabled: !!itemId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetItemDetailApiItemsItemIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>
>;
export type GetItemDetailApiItemsItemIdGetQueryError = HTTPValidationError;

/**
 * @summary Get Item Detail
 */

export function createGetItemDetailApiItemsItemIdGet<
  TData = Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getItemDetailApiItemsItemIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetItemDetailApiItemsItemIdGetQueryOptions(itemId, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update an existing item.
 * @summary Update Item
 */
export const updateItemApiItemsItemIdPatch = (itemId: string, itemUpdate: ItemUpdate) => {
  return customInstance<Item>({
    url: `/api/items/${itemId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: itemUpdate,
  });
};

export const getUpdateItemApiItemsItemIdPatchMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof updateItemApiItemsItemIdPatch>>,
    TError,
    { itemId: string; data: ItemUpdate },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof updateItemApiItemsItemIdPatch>>,
  TError,
  { itemId: string; data: ItemUpdate },
  TContext
> => {
  const mutationKey = ['updateItemApiItemsItemIdPatch'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateItemApiItemsItemIdPatch>>,
    { itemId: string; data: ItemUpdate }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return updateItemApiItemsItemIdPatch(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateItemApiItemsItemIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateItemApiItemsItemIdPatch>>
>;
export type UpdateItemApiItemsItemIdPatchMutationBody = ItemUpdate;
export type UpdateItemApiItemsItemIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Item
 */
export const createUpdateItemApiItemsItemIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof updateItemApiItemsItemIdPatch>>,
      TError,
      { itemId: string; data: ItemUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof updateItemApiItemsItemIdPatch>>,
  TError,
  { itemId: string; data: ItemUpdate },
  TContext
> => {
  const mutationOptions = getUpdateItemApiItemsItemIdPatchMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Delete an item.
 * @summary Delete Item
 */
export const deleteItemApiItemsItemIdDelete = (itemId: string) => {
  return customInstance<unknown>({ url: `/api/items/${itemId}`, method: 'DELETE' });
};

export const getDeleteItemApiItemsItemIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof deleteItemApiItemsItemIdDelete>>,
    TError,
    { itemId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof deleteItemApiItemsItemIdDelete>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationKey = ['deleteItemApiItemsItemIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItemApiItemsItemIdDelete>>,
    { itemId: string }
  > = (props) => {
    const { itemId } = props ?? {};

    return deleteItemApiItemsItemIdDelete(itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteItemApiItemsItemIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteItemApiItemsItemIdDelete>>
>;

export type DeleteItemApiItemsItemIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Item
 */
export const createDeleteItemApiItemsItemIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof deleteItemApiItemsItemIdDelete>>,
      TError,
      { itemId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof deleteItemApiItemsItemIdDelete>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationOptions = getDeleteItemApiItemsItemIdDeleteMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get all tags with usage count.
 * @summary Get Tags
 */
export const getTagsApiTagsGet = (signal?: AbortSignal) => {
  return customInstance<Tag[]>({ url: `/api/tags`, method: 'GET', signal });
};

export const getGetTagsApiTagsGetQueryKey = () => {
  return [`/api/tags`] as const;
};

export const getGetTagsApiTagsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTagsApiTagsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof getTagsApiTagsGet>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTagsApiTagsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTagsApiTagsGet>>> = ({ signal }) =>
    getTagsApiTagsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTagsApiTagsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTagsApiTagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTagsApiTagsGet>>
>;
export type GetTagsApiTagsGetQueryError = unknown;

/**
 * @summary Get Tags
 */

export function createGetTagsApiTagsGet<
  TData = Awaited<ReturnType<typeof getTagsApiTagsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getTagsApiTagsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTagsApiTagsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get recently used tags (last 10 unique tags).
 * @summary Get Recent Tags
 */
export const getRecentTagsApiTagsRecentGet = (signal?: AbortSignal) => {
  return customInstance<string[]>({ url: `/api/tags/recent`, method: 'GET', signal });
};

export const getGetRecentTagsApiTagsRecentGetQueryKey = () => {
  return [`/api/tags/recent`] as const;
};

export const getGetRecentTagsApiTagsRecentGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTagsApiTagsRecentGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>> = ({
    signal,
  }) => getRecentTagsApiTagsRecentGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentTagsApiTagsRecentGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>
>;
export type GetRecentTagsApiTagsRecentGetQueryError = unknown;

/**
 * @summary Get Recent Tags
 */

export function createGetRecentTagsApiTagsRecentGet<
  TData = Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getRecentTagsApiTagsRecentGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRecentTagsApiTagsRecentGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves current storage usage statistics for media files.
 * @summary Get Storage Statistics
 */
export const getStorageStatsApiAdminStorageStatsGet = (signal?: AbortSignal) => {
  return customInstance<GetStorageStatsApiAdminStorageStatsGet200>({
    url: `/api/admin/storage/stats`,
    method: 'GET',
    signal,
  });
};

export const getGetStorageStatsApiAdminStorageStatsGetQueryKey = () => {
  return [`/api/admin/storage/stats`] as const;
};

export const getGetStorageStatsApiAdminStorageStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStorageStatsApiAdminStorageStatsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>
  > = ({ signal }) => getStorageStatsApiAdminStorageStatsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStorageStatsApiAdminStorageStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>
>;
export type GetStorageStatsApiAdminStorageStatsGetQueryError = unknown;

/**
 * @summary Get Storage Statistics
 */

export function createGetStorageStatsApiAdminStorageStatsGet<
  TData = Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getStorageStatsApiAdminStorageStatsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetStorageStatsApiAdminStorageStatsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Triggers a cleanup process for orphaned media files (not referenced in DB).
 * @summary Run Orphaned File Cleanup
 */
export const runOrphanedCleanupApiAdminCleanupOrphanedPost = (signal?: AbortSignal) => {
  return customInstance<RunOrphanedCleanupApiAdminCleanupOrphanedPost200>({
    url: `/api/admin/cleanup/orphaned`,
    method: 'POST',
    signal,
  });
};

export const getRunOrphanedCleanupApiAdminCleanupOrphanedPostMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runOrphanedCleanupApiAdminCleanupOrphanedPost>>,
    TError,
    void,
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runOrphanedCleanupApiAdminCleanupOrphanedPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['runOrphanedCleanupApiAdminCleanupOrphanedPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runOrphanedCleanupApiAdminCleanupOrphanedPost>>,
    void
  > = () => {
    return runOrphanedCleanupApiAdminCleanupOrphanedPost();
  };

  return { mutationFn, ...mutationOptions };
};

export type RunOrphanedCleanupApiAdminCleanupOrphanedPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runOrphanedCleanupApiAdminCleanupOrphanedPost>>
>;

export type RunOrphanedCleanupApiAdminCleanupOrphanedPostMutationError = unknown;

/**
 * @summary Run Orphaned File Cleanup
 */
export const createRunOrphanedCleanupApiAdminCleanupOrphanedPost = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runOrphanedCleanupApiAdminCleanupOrphanedPost>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof runOrphanedCleanupApiAdminCleanupOrphanedPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRunOrphanedCleanupApiAdminCleanupOrphanedPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Triggers a cleanup process for temporary files older than specified hours.
 * @summary Run Temporary File Cleanup
 */
export const runTempCleanupApiAdminCleanupTempPost = (
  params?: RunTempCleanupApiAdminCleanupTempPostParams,
  signal?: AbortSignal
) => {
  return customInstance<RunTempCleanupApiAdminCleanupTempPost200>({
    url: `/api/admin/cleanup/temp`,
    method: 'POST',
    params,
    signal,
  });
};

export const getRunTempCleanupApiAdminCleanupTempPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runTempCleanupApiAdminCleanupTempPost>>,
    TError,
    { params?: RunTempCleanupApiAdminCleanupTempPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runTempCleanupApiAdminCleanupTempPost>>,
  TError,
  { params?: RunTempCleanupApiAdminCleanupTempPostParams },
  TContext
> => {
  const mutationKey = ['runTempCleanupApiAdminCleanupTempPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runTempCleanupApiAdminCleanupTempPost>>,
    { params?: RunTempCleanupApiAdminCleanupTempPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return runTempCleanupApiAdminCleanupTempPost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RunTempCleanupApiAdminCleanupTempPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runTempCleanupApiAdminCleanupTempPost>>
>;

export type RunTempCleanupApiAdminCleanupTempPostMutationError = HTTPValidationError;

/**
 * @summary Run Temporary File Cleanup
 */
export const createRunTempCleanupApiAdminCleanupTempPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runTempCleanupApiAdminCleanupTempPost>>,
      TError,
      { params?: RunTempCleanupApiAdminCleanupTempPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof runTempCleanupApiAdminCleanupTempPost>>,
  TError,
  { params?: RunTempCleanupApiAdminCleanupTempPostParams },
  TContext
> => {
  const mutationOptions = getRunTempCleanupApiAdminCleanupTempPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Debug endpoint to check items and their statuses.
 * @summary Debug Items
 */
export const debugItemsApiAdminDebugItemsGet = (signal?: AbortSignal) => {
  return customInstance<DebugItemsApiAdminDebugItemsGet200>({
    url: `/api/admin/debug/items`,
    method: 'GET',
    signal,
  });
};

export const getDebugItemsApiAdminDebugItemsGetQueryKey = () => {
  return [`/api/admin/debug/items`] as const;
};

export const getDebugItemsApiAdminDebugItemsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDebugItemsApiAdminDebugItemsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>> = ({
    signal,
  }) => debugItemsApiAdminDebugItemsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DebugItemsApiAdminDebugItemsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>
>;
export type DebugItemsApiAdminDebugItemsGetQueryError = unknown;

/**
 * @summary Debug Items
 */

export function createDebugItemsApiAdminDebugItemsGet<
  TData = Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof debugItemsApiAdminDebugItemsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDebugItemsApiAdminDebugItemsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a test item with completed status for debugging.
 * @summary Create Test Item
 */
export const createTestItemApiAdminTestCreateItemPost = (signal?: AbortSignal) => {
  return customInstance<CreateTestItemApiAdminTestCreateItemPost200>({
    url: `/api/admin/test/create-item`,
    method: 'POST',
    signal,
  });
};

export const getCreateTestItemApiAdminTestCreateItemPostMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof createTestItemApiAdminTestCreateItemPost>>,
    TError,
    void,
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof createTestItemApiAdminTestCreateItemPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['createTestItemApiAdminTestCreateItemPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTestItemApiAdminTestCreateItemPost>>,
    void
  > = () => {
    return createTestItemApiAdminTestCreateItemPost();
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTestItemApiAdminTestCreateItemPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTestItemApiAdminTestCreateItemPost>>
>;

export type CreateTestItemApiAdminTestCreateItemPostMutationError = unknown;

/**
 * @summary Create Test Item
 */
export const createCreateTestItemApiAdminTestCreateItemPost = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof createTestItemApiAdminTestCreateItemPost>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof createTestItemApiAdminTestCreateItemPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getCreateTestItemApiAdminTestCreateItemPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Streams a video file by its ID.
 * @summary Stream Video
 */
export const streamVideoApiVideosVideoIdStreamGet = (videoId: string, signal?: AbortSignal) => {
  return customInstance<void>({ url: `/api/videos/${videoId}/stream`, method: 'GET', signal });
};

export const getStreamVideoApiVideosVideoIdStreamGetQueryKey = (videoId: string) => {
  return [`/api/videos/${videoId}/stream`] as const;
};

export const getStreamVideoApiVideosVideoIdStreamGetQueryOptions = <
  TData = Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>,
  TError = HTTPValidationError,
>(
  videoId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStreamVideoApiVideosVideoIdStreamGetQueryKey(videoId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>
  > = ({ signal }) => streamVideoApiVideosVideoIdStreamGet(videoId, signal);

  return { queryKey, queryFn, enabled: !!videoId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamVideoApiVideosVideoIdStreamGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>
>;
export type StreamVideoApiVideosVideoIdStreamGetQueryError = HTTPValidationError;

/**
 * @summary Stream Video
 */

export function createStreamVideoApiVideosVideoIdStreamGet<
  TData = Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>,
  TError = HTTPValidationError,
>(
  videoId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof streamVideoApiVideosVideoIdStreamGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getStreamVideoApiVideosVideoIdStreamGetQueryOptions(videoId, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves metadata for a specific video by its ID.
 * @summary Get Video Metadata
 */
export const getVideoMetadataApiVideosVideoIdMetadataGet = (
  videoId: string,
  signal?: AbortSignal
) => {
  return customInstance<VideoInDB>({
    url: `/api/videos/${videoId}/metadata`,
    method: 'GET',
    signal,
  });
};

export const getGetVideoMetadataApiVideosVideoIdMetadataGetQueryKey = (videoId: string) => {
  return [`/api/videos/${videoId}/metadata`] as const;
};

export const getGetVideoMetadataApiVideosVideoIdMetadataGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>,
  TError = HTTPValidationError,
>(
  videoId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVideoMetadataApiVideosVideoIdMetadataGetQueryKey(videoId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>
  > = ({ signal }) => getVideoMetadataApiVideosVideoIdMetadataGet(videoId, signal);

  return { queryKey, queryFn, enabled: !!videoId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVideoMetadataApiVideosVideoIdMetadataGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>
>;
export type GetVideoMetadataApiVideosVideoIdMetadataGetQueryError = HTTPValidationError;

/**
 * @summary Get Video Metadata
 */

export function createGetVideoMetadataApiVideosVideoIdMetadataGet<
  TData = Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>,
  TError = HTTPValidationError,
>(
  videoId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoMetadataApiVideosVideoIdMetadataGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetVideoMetadataApiVideosVideoIdMetadataGetQueryOptions(videoId, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Downloads a video for offline viewing (only if not already downloaded).
 * @summary Download Video
 */
export const downloadVideoApiVideosVideoIdDownloadPost = (
  videoId: string,
  signal?: AbortSignal
) => {
  return customInstance<DownloadVideoApiVideosVideoIdDownloadPost200>({
    url: `/api/videos/${videoId}/download`,
    method: 'POST',
    signal,
  });
};

export const getDownloadVideoApiVideosVideoIdDownloadPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof downloadVideoApiVideosVideoIdDownloadPost>>,
    TError,
    { videoId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof downloadVideoApiVideosVideoIdDownloadPost>>,
  TError,
  { videoId: string },
  TContext
> => {
  const mutationKey = ['downloadVideoApiVideosVideoIdDownloadPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof downloadVideoApiVideosVideoIdDownloadPost>>,
    { videoId: string }
  > = (props) => {
    const { videoId } = props ?? {};

    return downloadVideoApiVideosVideoIdDownloadPost(videoId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DownloadVideoApiVideosVideoIdDownloadPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof downloadVideoApiVideosVideoIdDownloadPost>>
>;

export type DownloadVideoApiVideosVideoIdDownloadPostMutationError = HTTPValidationError;

/**
 * @summary Download Video
 */
export const createDownloadVideoApiVideosVideoIdDownloadPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof downloadVideoApiVideosVideoIdDownloadPost>>,
      TError,
      { videoId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof downloadVideoApiVideosVideoIdDownloadPost>>,
  TError,
  { videoId: string },
  TContext
> => {
  const mutationOptions = getDownloadVideoApiVideosVideoIdDownloadPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Gets the streaming URL/embed URL for a video.
 * @summary Get Video Stream URL
 */
export const getVideoStreamUrlApiVideosVideoIdStreamUrlGet = (
  videoId: string,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/videos/${videoId}/stream-url`,
    method: 'GET',
    signal,
  });
};

export const getGetVideoStreamUrlApiVideosVideoIdStreamUrlGetQueryKey = (videoId: string) => {
  return [`/api/videos/${videoId}/stream-url`] as const;
};

export const getGetVideoStreamUrlApiVideosVideoIdStreamUrlGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>,
  TError = HTTPValidationError,
>(
  videoId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVideoStreamUrlApiVideosVideoIdStreamUrlGetQueryKey(videoId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>
  > = ({ signal }) => getVideoStreamUrlApiVideosVideoIdStreamUrlGet(videoId, signal);

  return { queryKey, queryFn, enabled: !!videoId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVideoStreamUrlApiVideosVideoIdStreamUrlGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>
>;
export type GetVideoStreamUrlApiVideosVideoIdStreamUrlGetQueryError = HTTPValidationError;

/**
 * @summary Get Video Stream URL
 */

export function createGetVideoStreamUrlApiVideosVideoIdStreamUrlGet<
  TData = Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>,
  TError = HTTPValidationError,
>(
  videoId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoStreamUrlApiVideosVideoIdStreamUrlGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetVideoStreamUrlApiVideosVideoIdStreamUrlGetQueryOptions(
    videoId,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Requests transcoding of a video to a different quality. (Placeholder - not fully implemented)
 * @summary Request Video Transcoding
 */
export const requestVideoTranscodeApiVideosVideoIdTranscodePost = (
  videoId: string,
  params: RequestVideoTranscodeApiVideosVideoIdTranscodePostParams,
  signal?: AbortSignal
) => {
  return customInstance<RequestVideoTranscodeApiVideosVideoIdTranscodePost200>({
    url: `/api/videos/${videoId}/transcode`,
    method: 'POST',
    params,
    signal,
  });
};

export const getRequestVideoTranscodeApiVideosVideoIdTranscodePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof requestVideoTranscodeApiVideosVideoIdTranscodePost>>,
    TError,
    { videoId: string; params: RequestVideoTranscodeApiVideosVideoIdTranscodePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof requestVideoTranscodeApiVideosVideoIdTranscodePost>>,
  TError,
  { videoId: string; params: RequestVideoTranscodeApiVideosVideoIdTranscodePostParams },
  TContext
> => {
  const mutationKey = ['requestVideoTranscodeApiVideosVideoIdTranscodePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestVideoTranscodeApiVideosVideoIdTranscodePost>>,
    { videoId: string; params: RequestVideoTranscodeApiVideosVideoIdTranscodePostParams }
  > = (props) => {
    const { videoId, params } = props ?? {};

    return requestVideoTranscodeApiVideosVideoIdTranscodePost(videoId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestVideoTranscodeApiVideosVideoIdTranscodePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestVideoTranscodeApiVideosVideoIdTranscodePost>>
>;

export type RequestVideoTranscodeApiVideosVideoIdTranscodePostMutationError = HTTPValidationError;

/**
 * @summary Request Video Transcoding
 */
export const createRequestVideoTranscodeApiVideosVideoIdTranscodePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof requestVideoTranscodeApiVideosVideoIdTranscodePost>>,
      TError,
      { videoId: string; params: RequestVideoTranscodeApiVideosVideoIdTranscodePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof requestVideoTranscodeApiVideosVideoIdTranscodePost>>,
  TError,
  { videoId: string; params: RequestVideoTranscodeApiVideosVideoIdTranscodePostParams },
  TContext
> => {
  const mutationOptions =
    getRequestVideoTranscodeApiVideosVideoIdTranscodePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Deletes a video and its associated files from storage and database.
 * @summary Delete Video
 */
export const deleteVideoApiVideosVideoIdDelete = (videoId: string) => {
  return customInstance<void>({ url: `/api/videos/${videoId}`, method: 'DELETE' });
};

export const getDeleteVideoApiVideosVideoIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>,
    TError,
    { videoId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>,
  TError,
  { videoId: string },
  TContext
> => {
  const mutationKey = ['deleteVideoApiVideosVideoIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>,
    { videoId: string }
  > = (props) => {
    const { videoId } = props ?? {};

    return deleteVideoApiVideosVideoIdDelete(videoId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteVideoApiVideosVideoIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>
>;

export type DeleteVideoApiVideosVideoIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Video
 */
export const createDeleteVideoApiVideosVideoIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>,
      TError,
      { videoId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof deleteVideoApiVideosVideoIdDelete>>,
  TError,
  { videoId: string },
  TContext
> => {
  const mutationOptions = getDeleteVideoApiVideosVideoIdDeleteMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Analyze an image using vision AI
Extracts text, description, objects, and tags
 * @summary Analyze Image
 */
export const analyzeImageApiVisionAnalyzePost = (
  bodyAnalyzeImageApiVisionAnalyzePost: BodyAnalyzeImageApiVisionAnalyzePost,
  params?: AnalyzeImageApiVisionAnalyzePostParams,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`file`, bodyAnalyzeImageApiVisionAnalyzePost.file);

  return customInstance<AnalyzeImageApiVisionAnalyzePost200>({
    url: `/api/vision/analyze`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    params,
    signal,
  });
};

export const getAnalyzeImageApiVisionAnalyzePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof analyzeImageApiVisionAnalyzePost>>,
    TError,
    { data: BodyAnalyzeImageApiVisionAnalyzePost; params?: AnalyzeImageApiVisionAnalyzePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof analyzeImageApiVisionAnalyzePost>>,
  TError,
  { data: BodyAnalyzeImageApiVisionAnalyzePost; params?: AnalyzeImageApiVisionAnalyzePostParams },
  TContext
> => {
  const mutationKey = ['analyzeImageApiVisionAnalyzePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof analyzeImageApiVisionAnalyzePost>>,
    { data: BodyAnalyzeImageApiVisionAnalyzePost; params?: AnalyzeImageApiVisionAnalyzePostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return analyzeImageApiVisionAnalyzePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AnalyzeImageApiVisionAnalyzePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof analyzeImageApiVisionAnalyzePost>>
>;
export type AnalyzeImageApiVisionAnalyzePostMutationBody = BodyAnalyzeImageApiVisionAnalyzePost;
export type AnalyzeImageApiVisionAnalyzePostMutationError = HTTPValidationError;

/**
 * @summary Analyze Image
 */
export const createAnalyzeImageApiVisionAnalyzePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof analyzeImageApiVisionAnalyzePost>>,
      TError,
      {
        data: BodyAnalyzeImageApiVisionAnalyzePost;
        params?: AnalyzeImageApiVisionAnalyzePostParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof analyzeImageApiVisionAnalyzePost>>,
  TError,
  { data: BodyAnalyzeImageApiVisionAnalyzePost; params?: AnalyzeImageApiVisionAnalyzePostParams },
  TContext
> => {
  const mutationOptions = getAnalyzeImageApiVisionAnalyzePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Process a screenshot (from clipboard or drag-drop)
Automatically extracts and saves content
 * @summary Process Screenshot
 */
export const processScreenshotApiVisionScreenshotPost = (
  bodyProcessScreenshotApiVisionScreenshotPost: BodyProcessScreenshotApiVisionScreenshotPost,
  params?: ProcessScreenshotApiVisionScreenshotPostParams,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`file`, bodyProcessScreenshotApiVisionScreenshotPost.file);

  return customInstance<ProcessScreenshotApiVisionScreenshotPost200>({
    url: `/api/vision/screenshot`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    params,
    signal,
  });
};

export const getProcessScreenshotApiVisionScreenshotPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof processScreenshotApiVisionScreenshotPost>>,
    TError,
    {
      data: BodyProcessScreenshotApiVisionScreenshotPost;
      params?: ProcessScreenshotApiVisionScreenshotPostParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof processScreenshotApiVisionScreenshotPost>>,
  TError,
  {
    data: BodyProcessScreenshotApiVisionScreenshotPost;
    params?: ProcessScreenshotApiVisionScreenshotPostParams;
  },
  TContext
> => {
  const mutationKey = ['processScreenshotApiVisionScreenshotPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof processScreenshotApiVisionScreenshotPost>>,
    {
      data: BodyProcessScreenshotApiVisionScreenshotPost;
      params?: ProcessScreenshotApiVisionScreenshotPostParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return processScreenshotApiVisionScreenshotPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProcessScreenshotApiVisionScreenshotPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof processScreenshotApiVisionScreenshotPost>>
>;
export type ProcessScreenshotApiVisionScreenshotPostMutationBody =
  BodyProcessScreenshotApiVisionScreenshotPost;
export type ProcessScreenshotApiVisionScreenshotPostMutationError = HTTPValidationError;

/**
 * @summary Process Screenshot
 */
export const createProcessScreenshotApiVisionScreenshotPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof processScreenshotApiVisionScreenshotPost>>,
      TError,
      {
        data: BodyProcessScreenshotApiVisionScreenshotPost;
        params?: ProcessScreenshotApiVisionScreenshotPostParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof processScreenshotApiVisionScreenshotPost>>,
  TError,
  {
    data: BodyProcessScreenshotApiVisionScreenshotPost;
    params?: ProcessScreenshotApiVisionScreenshotPostParams;
  },
  TContext
> => {
  const mutationOptions = getProcessScreenshotApiVisionScreenshotPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get status of vision AI providers
 * @summary Get Vision Status
 */
export const getVisionStatusApiVisionStatusGet = (signal?: AbortSignal) => {
  return customInstance<GetVisionStatusApiVisionStatusGet200>({
    url: `/api/vision/status`,
    method: 'GET',
    signal,
  });
};

export const getGetVisionStatusApiVisionStatusGetQueryKey = () => {
  return [`/api/vision/status`] as const;
};

export const getGetVisionStatusApiVisionStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVisionStatusApiVisionStatusGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>> = ({
    signal,
  }) => getVisionStatusApiVisionStatusGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVisionStatusApiVisionStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>
>;
export type GetVisionStatusApiVisionStatusGetQueryError = unknown;

/**
 * @summary Get Vision Status
 */

export function createGetVisionStatusApiVisionStatusGet<
  TData = Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVisionStatusApiVisionStatusGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetVisionStatusApiVisionStatusGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get AI-powered suggestions for title, summary, and tags based on URL content.
This endpoint uses an AI router to ensure resilience and fallback capabilities.
 * @summary Get Ai Suggestions
 */
export const getAiSuggestionsApiSuggestPost = (
  suggestionRequest: SuggestionRequest,
  signal?: AbortSignal
) => {
  return customInstance<SuggestionResponse>({
    url: `/api/suggest`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: suggestionRequest,
    signal,
  });
};

export const getGetAiSuggestionsApiSuggestPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof getAiSuggestionsApiSuggestPost>>,
    TError,
    { data: SuggestionRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof getAiSuggestionsApiSuggestPost>>,
  TError,
  { data: SuggestionRequest },
  TContext
> => {
  const mutationKey = ['getAiSuggestionsApiSuggestPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getAiSuggestionsApiSuggestPost>>,
    { data: SuggestionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getAiSuggestionsApiSuggestPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetAiSuggestionsApiSuggestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof getAiSuggestionsApiSuggestPost>>
>;
export type GetAiSuggestionsApiSuggestPostMutationBody = SuggestionRequest;
export type GetAiSuggestionsApiSuggestPostMutationError = HTTPValidationError;

/**
 * @summary Get Ai Suggestions
 */
export const createGetAiSuggestionsApiSuggestPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof getAiSuggestionsApiSuggestPost>>,
      TError,
      { data: SuggestionRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof getAiSuggestionsApiSuggestPost>>,
  TError,
  { data: SuggestionRequest },
  TContext
> => {
  const mutationOptions = getGetAiSuggestionsApiSuggestPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get recently created items for debugging
 * @summary Get Recent Items
 */
export const getRecentItemsApiDebugRecentItemsGet = (
  params?: GetRecentItemsApiDebugRecentItemsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetRecentItemsApiDebugRecentItemsGet200>({
    url: `/api/debug/recent-items`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetRecentItemsApiDebugRecentItemsGetQueryKey = (
  params?: GetRecentItemsApiDebugRecentItemsGetParams
) => {
  return [`/api/debug/recent-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecentItemsApiDebugRecentItemsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRecentItemsApiDebugRecentItemsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecentItemsApiDebugRecentItemsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>
  > = ({ signal }) => getRecentItemsApiDebugRecentItemsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentItemsApiDebugRecentItemsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>
>;
export type GetRecentItemsApiDebugRecentItemsGetQueryError = HTTPValidationError;

/**
 * @summary Get Recent Items
 */

export function createGetRecentItemsApiDebugRecentItemsGet<
  TData = Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRecentItemsApiDebugRecentItemsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getRecentItemsApiDebugRecentItemsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRecentItemsApiDebugRecentItemsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get detailed processing status for a specific item
 * @summary Get Item Processing Status
 */
export const getItemProcessingStatusApiDebugItemProcessingItemIdGet = (
  itemId: string,
  signal?: AbortSignal
) => {
  return customInstance<GetItemProcessingStatusApiDebugItemProcessingItemIdGet200>({
    url: `/api/debug/item-processing/${itemId}`,
    method: 'GET',
    signal,
  });
};

export const getGetItemProcessingStatusApiDebugItemProcessingItemIdGetQueryKey = (
  itemId: string
) => {
  return [`/api/debug/item-processing/${itemId}`] as const;
};

export const getGetItemProcessingStatusApiDebugItemProcessingItemIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetItemProcessingStatusApiDebugItemProcessingItemIdGetQueryKey(itemId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>
  > = ({ signal }) => getItemProcessingStatusApiDebugItemProcessingItemIdGet(itemId, signal);

  return { queryKey, queryFn, enabled: !!itemId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetItemProcessingStatusApiDebugItemProcessingItemIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>
>;
export type GetItemProcessingStatusApiDebugItemProcessingItemIdGetQueryError = HTTPValidationError;

/**
 * @summary Get Item Processing Status
 */

export function createGetItemProcessingStatusApiDebugItemProcessingItemIdGet<
  TData = Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getItemProcessingStatusApiDebugItemProcessingItemIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetItemProcessingStatusApiDebugItemProcessingItemIdGetQueryOptions(
    itemId,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all registered routes for debugging
 * @summary Get All Routes
 */
export const getAllRoutesApiDebugRoutesGet = (signal?: AbortSignal) => {
  return customInstance<GetAllRoutesApiDebugRoutesGet200>({
    url: `/api/debug/routes`,
    method: 'GET',
    signal,
  });
};

export const getGetAllRoutesApiDebugRoutesGetQueryKey = () => {
  return [`/api/debug/routes`] as const;
};

export const getGetAllRoutesApiDebugRoutesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllRoutesApiDebugRoutesGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>> = ({
    signal,
  }) => getAllRoutesApiDebugRoutesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllRoutesApiDebugRoutesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>
>;
export type GetAllRoutesApiDebugRoutesGetQueryError = unknown;

/**
 * @summary Get All Routes
 */

export function createGetAllRoutesApiDebugRoutesGet<
  TData = Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getAllRoutesApiDebugRoutesGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllRoutesApiDebugRoutesGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves content trends over a specified timeframe.
 * @summary Get Content Trends
 */
export const getContentTrendsApiAnalyticsTrendsGet = (
  params?: GetContentTrendsApiAnalyticsTrendsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/analytics/trends`, method: 'GET', params, signal });
};

export const getGetContentTrendsApiAnalyticsTrendsGetQueryKey = (
  params?: GetContentTrendsApiAnalyticsTrendsGetParams
) => {
  return [`/api/analytics/trends`, ...(params ? [params] : [])] as const;
};

export const getGetContentTrendsApiAnalyticsTrendsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetContentTrendsApiAnalyticsTrendsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetContentTrendsApiAnalyticsTrendsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>
  > = ({ signal }) => getContentTrendsApiAnalyticsTrendsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetContentTrendsApiAnalyticsTrendsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>
>;
export type GetContentTrendsApiAnalyticsTrendsGetQueryError = HTTPValidationError;

/**
 * @summary Get Content Trends
 */

export function createGetContentTrendsApiAnalyticsTrendsGet<
  TData = Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetContentTrendsApiAnalyticsTrendsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getContentTrendsApiAnalyticsTrendsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetContentTrendsApiAnalyticsTrendsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves top topics or tags based on frequency.
 * @summary Get Topic Clustering
 */
export const getTopicClusteringApiAnalyticsTopicsGet = (
  params?: GetTopicClusteringApiAnalyticsTopicsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/analytics/topics`, method: 'GET', params, signal });
};

export const getGetTopicClusteringApiAnalyticsTopicsGetQueryKey = (
  params?: GetTopicClusteringApiAnalyticsTopicsGetParams
) => {
  return [`/api/analytics/topics`, ...(params ? [params] : [])] as const;
};

export const getGetTopicClusteringApiAnalyticsTopicsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTopicClusteringApiAnalyticsTopicsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTopicClusteringApiAnalyticsTopicsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>
  > = ({ signal }) => getTopicClusteringApiAnalyticsTopicsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTopicClusteringApiAnalyticsTopicsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>
>;
export type GetTopicClusteringApiAnalyticsTopicsGetQueryError = HTTPValidationError;

/**
 * @summary Get Topic Clustering
 */

export function createGetTopicClusteringApiAnalyticsTopicsGet<
  TData = Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTopicClusteringApiAnalyticsTopicsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTopicClusteringApiAnalyticsTopicsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTopicClusteringApiAnalyticsTopicsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves general usage patterns (e.g., total items, average items per day).
 * @summary Get Usage Patterns
 */
export const getUsagePatternsApiAnalyticsUsagePatternsGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/analytics/usage_patterns`, method: 'GET', signal });
};

export const getGetUsagePatternsApiAnalyticsUsagePatternsGetQueryKey = () => {
  return [`/api/analytics/usage_patterns`] as const;
};

export const getGetUsagePatternsApiAnalyticsUsagePatternsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUsagePatternsApiAnalyticsUsagePatternsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>
  > = ({ signal }) => getUsagePatternsApiAnalyticsUsagePatternsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsagePatternsApiAnalyticsUsagePatternsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>
>;
export type GetUsagePatternsApiAnalyticsUsagePatternsGetQueryError = unknown;

/**
 * @summary Get Usage Patterns
 */

export function createGetUsagePatternsApiAnalyticsUsagePatternsGet<
  TData = Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getUsagePatternsApiAnalyticsUsagePatternsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUsagePatternsApiAnalyticsUsagePatternsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves AI-generated insights based on recent content.
 * @summary Get Ai Generated Insights
 */
export const getAiGeneratedInsightsApiAnalyticsAiInsightsGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/analytics/ai_insights`, method: 'GET', signal });
};

export const getGetAiGeneratedInsightsApiAnalyticsAiInsightsGetQueryKey = () => {
  return [`/api/analytics/ai_insights`] as const;
};

export const getGetAiGeneratedInsightsApiAnalyticsAiInsightsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAiGeneratedInsightsApiAnalyticsAiInsightsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>
  > = ({ signal }) => getAiGeneratedInsightsApiAnalyticsAiInsightsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAiGeneratedInsightsApiAnalyticsAiInsightsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>
>;
export type GetAiGeneratedInsightsApiAnalyticsAiInsightsGetQueryError = unknown;

/**
 * @summary Get Ai Generated Insights
 */

export function createGetAiGeneratedInsightsApiAnalyticsAiInsightsGet<
  TData = Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getAiGeneratedInsightsApiAnalyticsAiInsightsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAiGeneratedInsightsApiAnalyticsAiInsightsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get suggested questions based on context.

This is a placeholder that returns static questions.
In the future, this will use Azure AI models to generate contextual questions.
 * @summary Suggest Questions
 */
export const suggestQuestionsApiSuggestQuestionsGet = (
  params?: SuggestQuestionsApiSuggestQuestionsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/suggest-questions`, method: 'GET', params, signal });
};

export const getSuggestQuestionsApiSuggestQuestionsGetQueryKey = (
  params?: SuggestQuestionsApiSuggestQuestionsGetParams
) => {
  return [`/api/suggest-questions`, ...(params ? [params] : [])] as const;
};

export const getSuggestQuestionsApiSuggestQuestionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>,
  TError = HTTPValidationError,
>(
  params?: SuggestQuestionsApiSuggestQuestionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuggestQuestionsApiSuggestQuestionsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>
  > = ({ signal }) => suggestQuestionsApiSuggestQuestionsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuggestQuestionsApiSuggestQuestionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>
>;
export type SuggestQuestionsApiSuggestQuestionsGetQueryError = HTTPValidationError;

/**
 * @summary Suggest Questions
 */

export function createSuggestQuestionsApiSuggestQuestionsGet<
  TData = Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>,
  TError = HTTPValidationError,
>(
  params?: SuggestQuestionsApiSuggestQuestionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof suggestQuestionsApiSuggestQuestionsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSuggestQuestionsApiSuggestQuestionsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Version 1 endpoint for backward compatibility.
Redirects to the main suggest-questions endpoint.
 * @summary Suggest Questions V1
 */
export const suggestQuestionsV1ApiV1SuggestQuestionsGet = (
  params?: SuggestQuestionsV1ApiV1SuggestQuestionsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/v1/suggest-questions`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSuggestQuestionsV1ApiV1SuggestQuestionsGetQueryKey = (
  params?: SuggestQuestionsV1ApiV1SuggestQuestionsGetParams
) => {
  return [`/api/v1/suggest-questions`, ...(params ? [params] : [])] as const;
};

export const getSuggestQuestionsV1ApiV1SuggestQuestionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>,
  TError = HTTPValidationError,
>(
  params?: SuggestQuestionsV1ApiV1SuggestQuestionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuggestQuestionsV1ApiV1SuggestQuestionsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>
  > = ({ signal }) => suggestQuestionsV1ApiV1SuggestQuestionsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuggestQuestionsV1ApiV1SuggestQuestionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>
>;
export type SuggestQuestionsV1ApiV1SuggestQuestionsGetQueryError = HTTPValidationError;

/**
 * @summary Suggest Questions V1
 */

export function createSuggestQuestionsV1ApiV1SuggestQuestionsGet<
  TData = Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>,
  TError = HTTPValidationError,
>(
  params?: SuggestQuestionsV1ApiV1SuggestQuestionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof suggestQuestionsV1ApiV1SuggestQuestionsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSuggestQuestionsV1ApiV1SuggestQuestionsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Process a saved item as a video - extract metadata, transcript, and analyze content
 * @summary Process Video
 */
export const processVideoApiVideoStreamingProcessPost = (
  processVideoRequest: ProcessVideoRequest,
  params?: ProcessVideoApiVideoStreamingProcessPostParams,
  signal?: AbortSignal
) => {
  return customInstance<VideoResponse>({
    url: `/api/video-streaming/process`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: processVideoRequest,
    params,
    signal,
  });
};

export const getProcessVideoApiVideoStreamingProcessPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof processVideoApiVideoStreamingProcessPost>>,
    TError,
    { data: ProcessVideoRequest; params?: ProcessVideoApiVideoStreamingProcessPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof processVideoApiVideoStreamingProcessPost>>,
  TError,
  { data: ProcessVideoRequest; params?: ProcessVideoApiVideoStreamingProcessPostParams },
  TContext
> => {
  const mutationKey = ['processVideoApiVideoStreamingProcessPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof processVideoApiVideoStreamingProcessPost>>,
    { data: ProcessVideoRequest; params?: ProcessVideoApiVideoStreamingProcessPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return processVideoApiVideoStreamingProcessPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProcessVideoApiVideoStreamingProcessPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof processVideoApiVideoStreamingProcessPost>>
>;
export type ProcessVideoApiVideoStreamingProcessPostMutationBody = ProcessVideoRequest;
export type ProcessVideoApiVideoStreamingProcessPostMutationError = HTTPValidationError;

/**
 * @summary Process Video
 */
export const createProcessVideoApiVideoStreamingProcessPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof processVideoApiVideoStreamingProcessPost>>,
      TError,
      { data: ProcessVideoRequest; params?: ProcessVideoApiVideoStreamingProcessPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof processVideoApiVideoStreamingProcessPost>>,
  TError,
  { data: ProcessVideoRequest; params?: ProcessVideoApiVideoStreamingProcessPostParams },
  TContext
> => {
  const mutationOptions = getProcessVideoApiVideoStreamingProcessPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Find videos related to a specific video
 * @summary Find Related Videos
 */
export const findRelatedVideosApiVideoStreamingRelatedPost = (
  findRelatedRequest: FindRelatedRequest,
  params?: FindRelatedVideosApiVideoStreamingRelatedPostParams,
  signal?: AbortSignal
) => {
  return customInstance<VideoResponse>({
    url: `/api/video-streaming/related`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: findRelatedRequest,
    params,
    signal,
  });
};

export const getFindRelatedVideosApiVideoStreamingRelatedPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof findRelatedVideosApiVideoStreamingRelatedPost>>,
    TError,
    { data: FindRelatedRequest; params?: FindRelatedVideosApiVideoStreamingRelatedPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof findRelatedVideosApiVideoStreamingRelatedPost>>,
  TError,
  { data: FindRelatedRequest; params?: FindRelatedVideosApiVideoStreamingRelatedPostParams },
  TContext
> => {
  const mutationKey = ['findRelatedVideosApiVideoStreamingRelatedPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof findRelatedVideosApiVideoStreamingRelatedPost>>,
    { data: FindRelatedRequest; params?: FindRelatedVideosApiVideoStreamingRelatedPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return findRelatedVideosApiVideoStreamingRelatedPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type FindRelatedVideosApiVideoStreamingRelatedPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof findRelatedVideosApiVideoStreamingRelatedPost>>
>;
export type FindRelatedVideosApiVideoStreamingRelatedPostMutationBody = FindRelatedRequest;
export type FindRelatedVideosApiVideoStreamingRelatedPostMutationError = HTTPValidationError;

/**
 * @summary Find Related Videos
 */
export const createFindRelatedVideosApiVideoStreamingRelatedPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof findRelatedVideosApiVideoStreamingRelatedPost>>,
      TError,
      { data: FindRelatedRequest; params?: FindRelatedVideosApiVideoStreamingRelatedPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof findRelatedVideosApiVideoStreamingRelatedPost>>,
  TError,
  { data: FindRelatedRequest; params?: FindRelatedVideosApiVideoStreamingRelatedPostParams },
  TContext
> => {
  const mutationOptions = getFindRelatedVideosApiVideoStreamingRelatedPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Create a mini-course from saved videos on a topic
 * @summary Create Mini Course
 */
export const createMiniCourseApiVideoStreamingMiniCoursePost = (
  createMiniCourseRequest: CreateMiniCourseRequest,
  params?: CreateMiniCourseApiVideoStreamingMiniCoursePostParams,
  signal?: AbortSignal
) => {
  return customInstance<VideoResponse>({
    url: `/api/video-streaming/mini-course`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createMiniCourseRequest,
    params,
    signal,
  });
};

export const getCreateMiniCourseApiVideoStreamingMiniCoursePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof createMiniCourseApiVideoStreamingMiniCoursePost>>,
    TError,
    {
      data: CreateMiniCourseRequest;
      params?: CreateMiniCourseApiVideoStreamingMiniCoursePostParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof createMiniCourseApiVideoStreamingMiniCoursePost>>,
  TError,
  { data: CreateMiniCourseRequest; params?: CreateMiniCourseApiVideoStreamingMiniCoursePostParams },
  TContext
> => {
  const mutationKey = ['createMiniCourseApiVideoStreamingMiniCoursePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMiniCourseApiVideoStreamingMiniCoursePost>>,
    {
      data: CreateMiniCourseRequest;
      params?: CreateMiniCourseApiVideoStreamingMiniCoursePostParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return createMiniCourseApiVideoStreamingMiniCoursePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMiniCourseApiVideoStreamingMiniCoursePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMiniCourseApiVideoStreamingMiniCoursePost>>
>;
export type CreateMiniCourseApiVideoStreamingMiniCoursePostMutationBody = CreateMiniCourseRequest;
export type CreateMiniCourseApiVideoStreamingMiniCoursePostMutationError = HTTPValidationError;

/**
 * @summary Create Mini Course
 */
export const createCreateMiniCourseApiVideoStreamingMiniCoursePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof createMiniCourseApiVideoStreamingMiniCoursePost>>,
      TError,
      {
        data: CreateMiniCourseRequest;
        params?: CreateMiniCourseApiVideoStreamingMiniCoursePostParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof createMiniCourseApiVideoStreamingMiniCoursePost>>,
  TError,
  { data: CreateMiniCourseRequest; params?: CreateMiniCourseApiVideoStreamingMiniCoursePostParams },
  TContext
> => {
  const mutationOptions =
    getCreateMiniCourseApiVideoStreamingMiniCoursePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get timeline of video items with filtering options
 * @summary Get Video Timeline
 */
export const getVideoTimelineApiVideoStreamingTimelineGet = (
  params?: GetVideoTimelineApiVideoStreamingTimelineGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/video-streaming/timeline`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetVideoTimelineApiVideoStreamingTimelineGetQueryKey = (
  params?: GetVideoTimelineApiVideoStreamingTimelineGetParams
) => {
  return [`/api/video-streaming/timeline`, ...(params ? [params] : [])] as const;
};

export const getGetVideoTimelineApiVideoStreamingTimelineGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>,
  TError = HTTPValidationError,
>(
  params?: GetVideoTimelineApiVideoStreamingTimelineGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVideoTimelineApiVideoStreamingTimelineGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>
  > = ({ signal }) => getVideoTimelineApiVideoStreamingTimelineGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVideoTimelineApiVideoStreamingTimelineGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>
>;
export type GetVideoTimelineApiVideoStreamingTimelineGetQueryError = HTTPValidationError;

/**
 * @summary Get Video Timeline
 */

export function createGetVideoTimelineApiVideoStreamingTimelineGet<
  TData = Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>,
  TError = HTTPValidationError,
>(
  params?: GetVideoTimelineApiVideoStreamingTimelineGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoTimelineApiVideoStreamingTimelineGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetVideoTimelineApiVideoStreamingTimelineGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Check if a URL is a supported video and extract basic info
 * @summary Check Video Url
 */
export const checkVideoUrlApiVideoStreamingCheckUrlGet = (
  params: CheckVideoUrlApiVideoStreamingCheckUrlGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/video-streaming/check-url`,
    method: 'GET',
    params,
    signal,
  });
};

export const getCheckVideoUrlApiVideoStreamingCheckUrlGetQueryKey = (
  params: CheckVideoUrlApiVideoStreamingCheckUrlGetParams
) => {
  return [`/api/video-streaming/check-url`, ...(params ? [params] : [])] as const;
};

export const getCheckVideoUrlApiVideoStreamingCheckUrlGetQueryOptions = <
  TData = Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>,
  TError = HTTPValidationError,
>(
  params: CheckVideoUrlApiVideoStreamingCheckUrlGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCheckVideoUrlApiVideoStreamingCheckUrlGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>
  > = ({ signal }) => checkVideoUrlApiVideoStreamingCheckUrlGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CheckVideoUrlApiVideoStreamingCheckUrlGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>
>;
export type CheckVideoUrlApiVideoStreamingCheckUrlGetQueryError = HTTPValidationError;

/**
 * @summary Check Video Url
 */

export function createCheckVideoUrlApiVideoStreamingCheckUrlGet<
  TData = Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>,
  TError = HTTPValidationError,
>(
  params: CheckVideoUrlApiVideoStreamingCheckUrlGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof checkVideoUrlApiVideoStreamingCheckUrlGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCheckVideoUrlApiVideoStreamingCheckUrlGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Process all unprocessed video items in the database
 * @summary Batch Process Videos
 */
export const batchProcessVideosApiVideoStreamingBatchProcessPost = (
  params?: BatchProcessVideosApiVideoStreamingBatchProcessPostParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/video-streaming/batch-process`,
    method: 'POST',
    params,
    signal,
  });
};

export const getBatchProcessVideosApiVideoStreamingBatchProcessPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof batchProcessVideosApiVideoStreamingBatchProcessPost>>,
    TError,
    { params?: BatchProcessVideosApiVideoStreamingBatchProcessPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof batchProcessVideosApiVideoStreamingBatchProcessPost>>,
  TError,
  { params?: BatchProcessVideosApiVideoStreamingBatchProcessPostParams },
  TContext
> => {
  const mutationKey = ['batchProcessVideosApiVideoStreamingBatchProcessPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof batchProcessVideosApiVideoStreamingBatchProcessPost>>,
    { params?: BatchProcessVideosApiVideoStreamingBatchProcessPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return batchProcessVideosApiVideoStreamingBatchProcessPost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type BatchProcessVideosApiVideoStreamingBatchProcessPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof batchProcessVideosApiVideoStreamingBatchProcessPost>>
>;

export type BatchProcessVideosApiVideoStreamingBatchProcessPostMutationError = HTTPValidationError;

/**
 * @summary Batch Process Videos
 */
export const createBatchProcessVideosApiVideoStreamingBatchProcessPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof batchProcessVideosApiVideoStreamingBatchProcessPost>>,
      TError,
      { params?: BatchProcessVideosApiVideoStreamingBatchProcessPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof batchProcessVideosApiVideoStreamingBatchProcessPost>>,
  TError,
  { params?: BatchProcessVideosApiVideoStreamingBatchProcessPostParams },
  TContext
> => {
  const mutationOptions =
    getBatchProcessVideosApiVideoStreamingBatchProcessPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get previously created mini-courses
 * @summary Get Saved Mini Courses
 */
export const getSavedMiniCoursesApiVideoStreamingMiniCoursesGet = (
  params?: GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/video-streaming/mini-courses`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetSavedMiniCoursesApiVideoStreamingMiniCoursesGetQueryKey = (
  params?: GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetParams
) => {
  return [`/api/video-streaming/mini-courses`, ...(params ? [params] : [])] as const;
};

export const getGetSavedMiniCoursesApiVideoStreamingMiniCoursesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSavedMiniCoursesApiVideoStreamingMiniCoursesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>
  > = ({ signal }) => getSavedMiniCoursesApiVideoStreamingMiniCoursesGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>
>;
export type GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetQueryError = HTTPValidationError;

/**
 * @summary Get Saved Mini Courses
 */

export function createGetSavedMiniCoursesApiVideoStreamingMiniCoursesGet<
  TData = Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSavedMiniCoursesApiVideoStreamingMiniCoursesGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getSavedMiniCoursesApiVideoStreamingMiniCoursesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSavedMiniCoursesApiVideoStreamingMiniCoursesGetQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get statistics about video content
 * @summary Get Video Stats
 */
export const getVideoStatsApiVideoStreamingStatsGet = (
  params?: GetVideoStatsApiVideoStreamingStatsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/video-streaming/stats`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetVideoStatsApiVideoStreamingStatsGetQueryKey = (
  params?: GetVideoStatsApiVideoStreamingStatsGetParams
) => {
  return [`/api/video-streaming/stats`, ...(params ? [params] : [])] as const;
};

export const getGetVideoStatsApiVideoStreamingStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetVideoStatsApiVideoStreamingStatsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVideoStatsApiVideoStreamingStatsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>
  > = ({ signal }) => getVideoStatsApiVideoStreamingStatsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVideoStatsApiVideoStreamingStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>
>;
export type GetVideoStatsApiVideoStreamingStatsGetQueryError = HTTPValidationError;

/**
 * @summary Get Video Stats
 */

export function createGetVideoStatsApiVideoStreamingStatsGet<
  TData = Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetVideoStatsApiVideoStreamingStatsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getVideoStatsApiVideoStreamingStatsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetVideoStatsApiVideoStreamingStatsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Categorize content using AI analysis
 * @summary Categorize Content
 */
export const categorizeContentApiCategorizePost = (
  categorizationRequest: CategorizationRequest,
  signal?: AbortSignal
) => {
  return customInstance<CategorizationResponse>({
    url: `/api/categorize`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: categorizationRequest,
    signal,
  });
};

export const getCategorizeContentApiCategorizePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof categorizeContentApiCategorizePost>>,
    TError,
    { data: CategorizationRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof categorizeContentApiCategorizePost>>,
  TError,
  { data: CategorizationRequest },
  TContext
> => {
  const mutationKey = ['categorizeContentApiCategorizePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof categorizeContentApiCategorizePost>>,
    { data: CategorizationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return categorizeContentApiCategorizePost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CategorizeContentApiCategorizePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof categorizeContentApiCategorizePost>>
>;
export type CategorizeContentApiCategorizePostMutationBody = CategorizationRequest;
export type CategorizeContentApiCategorizePostMutationError = HTTPValidationError;

/**
 * @summary Categorize Content
 */
export const createCategorizeContentApiCategorizePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof categorizeContentApiCategorizePost>>,
      TError,
      { data: CategorizationRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof categorizeContentApiCategorizePost>>,
  TError,
  { data: CategorizationRequest },
  TContext
> => {
  const mutationOptions = getCategorizeContentApiCategorizePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Categorize multiple uncategorized items in bulk
 * @summary Bulk Categorize
 */
export const bulkCategorizeApiCategorizeBulkPost = (
  params?: BulkCategorizeApiCategorizeBulkPostParams,
  signal?: AbortSignal
) => {
  return customInstance<BulkCategorizationResponse>({
    url: `/api/categorize/bulk`,
    method: 'POST',
    params,
    signal,
  });
};

export const getBulkCategorizeApiCategorizeBulkPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof bulkCategorizeApiCategorizeBulkPost>>,
    TError,
    { params?: BulkCategorizeApiCategorizeBulkPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof bulkCategorizeApiCategorizeBulkPost>>,
  TError,
  { params?: BulkCategorizeApiCategorizeBulkPostParams },
  TContext
> => {
  const mutationKey = ['bulkCategorizeApiCategorizeBulkPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkCategorizeApiCategorizeBulkPost>>,
    { params?: BulkCategorizeApiCategorizeBulkPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return bulkCategorizeApiCategorizeBulkPost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type BulkCategorizeApiCategorizeBulkPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkCategorizeApiCategorizeBulkPost>>
>;

export type BulkCategorizeApiCategorizeBulkPostMutationError = HTTPValidationError;

/**
 * @summary Bulk Categorize
 */
export const createBulkCategorizeApiCategorizeBulkPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof bulkCategorizeApiCategorizeBulkPost>>,
      TError,
      { params?: BulkCategorizeApiCategorizeBulkPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof bulkCategorizeApiCategorizeBulkPost>>,
  TError,
  { params?: BulkCategorizeApiCategorizeBulkPostParams },
  TContext
> => {
  const mutationOptions = getBulkCategorizeApiCategorizeBulkPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get suggested connections for an item based on content analysis
 * @summary Get Item Connections
 */
export const getItemConnectionsApiItemsItemIdConnectionsGet = (
  itemId: string,
  params?: GetItemConnectionsApiItemsItemIdConnectionsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<ItemConnectionResponse[]>({
    url: `/api/items/${itemId}/connections`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetItemConnectionsApiItemsItemIdConnectionsGetQueryKey = (
  itemId: string,
  params?: GetItemConnectionsApiItemsItemIdConnectionsGetParams
) => {
  return [`/api/items/${itemId}/connections`, ...(params ? [params] : [])] as const;
};

export const getGetItemConnectionsApiItemsItemIdConnectionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  params?: GetItemConnectionsApiItemsItemIdConnectionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetItemConnectionsApiItemsItemIdConnectionsGetQueryKey(itemId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>
  > = ({ signal }) => getItemConnectionsApiItemsItemIdConnectionsGet(itemId, params, signal);

  return { queryKey, queryFn, enabled: !!itemId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetItemConnectionsApiItemsItemIdConnectionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>
>;
export type GetItemConnectionsApiItemsItemIdConnectionsGetQueryError = HTTPValidationError;

/**
 * @summary Get Item Connections
 */

export function createGetItemConnectionsApiItemsItemIdConnectionsGet<
  TData = Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  params?: GetItemConnectionsApiItemsItemIdConnectionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getItemConnectionsApiItemsItemIdConnectionsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetItemConnectionsApiItemsItemIdConnectionsGetQueryOptions(
    itemId,
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reorganize content based on semantic clustering
 * @summary Reorganize By Clusters
 */
export const reorganizeByClustersApiReorganizeClustersPost = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/reorganize/clusters`, method: 'POST', signal });
};

export const getReorganizeByClustersApiReorganizeClustersPostMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof reorganizeByClustersApiReorganizeClustersPost>>,
    TError,
    void,
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof reorganizeByClustersApiReorganizeClustersPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['reorganizeByClustersApiReorganizeClustersPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reorganizeByClustersApiReorganizeClustersPost>>,
    void
  > = () => {
    return reorganizeByClustersApiReorganizeClustersPost();
  };

  return { mutationFn, ...mutationOptions };
};

export type ReorganizeByClustersApiReorganizeClustersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof reorganizeByClustersApiReorganizeClustersPost>>
>;

export type ReorganizeByClustersApiReorganizeClustersPostMutationError = unknown;

/**
 * @summary Reorganize By Clusters
 */
export const createReorganizeByClustersApiReorganizeClustersPost = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof reorganizeByClustersApiReorganizeClustersPost>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof reorganizeByClustersApiReorganizeClustersPost>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getReorganizeByClustersApiReorganizeClustersPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get statistics about content categories
 * @summary Get Category Statistics
 */
export const getCategoryStatisticsApiCategoriesStatsGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/categories/stats`, method: 'GET', signal });
};

export const getGetCategoryStatisticsApiCategoriesStatsGetQueryKey = () => {
  return [`/api/categories/stats`] as const;
};

export const getGetCategoryStatisticsApiCategoriesStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoryStatisticsApiCategoriesStatsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>
  > = ({ signal }) => getCategoryStatisticsApiCategoriesStatsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoryStatisticsApiCategoriesStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>
>;
export type GetCategoryStatisticsApiCategoriesStatsGetQueryError = unknown;

/**
 * @summary Get Category Statistics
 */

export function createGetCategoryStatisticsApiCategoriesStatsGet<
  TData = Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getCategoryStatisticsApiCategoriesStatsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCategoryStatisticsApiCategoriesStatsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Check if content is a duplicate before saving
 * @summary Check Duplicate
 */
export const checkDuplicateApiDuplicatesCheckPost = (
  duplicateCheckRequest: DuplicateCheckRequest,
  signal?: AbortSignal
) => {
  return customInstance<DuplicateCheckResponse>({
    url: `/api/duplicates/check`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: duplicateCheckRequest,
    signal,
  });
};

export const getCheckDuplicateApiDuplicatesCheckPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof checkDuplicateApiDuplicatesCheckPost>>,
    TError,
    { data: DuplicateCheckRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof checkDuplicateApiDuplicatesCheckPost>>,
  TError,
  { data: DuplicateCheckRequest },
  TContext
> => {
  const mutationKey = ['checkDuplicateApiDuplicatesCheckPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkDuplicateApiDuplicatesCheckPost>>,
    { data: DuplicateCheckRequest }
  > = (props) => {
    const { data } = props ?? {};

    return checkDuplicateApiDuplicatesCheckPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckDuplicateApiDuplicatesCheckPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkDuplicateApiDuplicatesCheckPost>>
>;
export type CheckDuplicateApiDuplicatesCheckPostMutationBody = DuplicateCheckRequest;
export type CheckDuplicateApiDuplicatesCheckPostMutationError = HTTPValidationError;

/**
 * @summary Check Duplicate
 */
export const createCheckDuplicateApiDuplicatesCheckPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof checkDuplicateApiDuplicatesCheckPost>>,
      TError,
      { data: DuplicateCheckRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof checkDuplicateApiDuplicatesCheckPost>>,
  TError,
  { data: DuplicateCheckRequest },
  TContext
> => {
  const mutationOptions = getCheckDuplicateApiDuplicatesCheckPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Find all duplicate groups in the database
 * @summary Find All Duplicates
 */
export const findAllDuplicatesApiDuplicatesFindAllGet = (
  params?: FindAllDuplicatesApiDuplicatesFindAllGetParams,
  signal?: AbortSignal
) => {
  return customInstance<DuplicateGroup[]>({
    url: `/api/duplicates/find-all`,
    method: 'GET',
    params,
    signal,
  });
};

export const getFindAllDuplicatesApiDuplicatesFindAllGetQueryKey = (
  params?: FindAllDuplicatesApiDuplicatesFindAllGetParams
) => {
  return [`/api/duplicates/find-all`, ...(params ? [params] : [])] as const;
};

export const getFindAllDuplicatesApiDuplicatesFindAllGetQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>,
  TError = HTTPValidationError,
>(
  params?: FindAllDuplicatesApiDuplicatesFindAllGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindAllDuplicatesApiDuplicatesFindAllGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>
  > = ({ signal }) => findAllDuplicatesApiDuplicatesFindAllGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindAllDuplicatesApiDuplicatesFindAllGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>
>;
export type FindAllDuplicatesApiDuplicatesFindAllGetQueryError = HTTPValidationError;

/**
 * @summary Find All Duplicates
 */

export function createFindAllDuplicatesApiDuplicatesFindAllGet<
  TData = Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>,
  TError = HTTPValidationError,
>(
  params?: FindAllDuplicatesApiDuplicatesFindAllGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof findAllDuplicatesApiDuplicatesFindAllGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindAllDuplicatesApiDuplicatesFindAllGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Merge duplicate items into one
 * @summary Merge Duplicates
 */
export const mergeDuplicatesApiDuplicatesMergePost = (
  mergeDuplicatesRequest: MergeDuplicatesRequest,
  signal?: AbortSignal
) => {
  return customInstance<MergeDuplicatesResponse>({
    url: `/api/duplicates/merge`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: mergeDuplicatesRequest,
    signal,
  });
};

export const getMergeDuplicatesApiDuplicatesMergePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof mergeDuplicatesApiDuplicatesMergePost>>,
    TError,
    { data: MergeDuplicatesRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof mergeDuplicatesApiDuplicatesMergePost>>,
  TError,
  { data: MergeDuplicatesRequest },
  TContext
> => {
  const mutationKey = ['mergeDuplicatesApiDuplicatesMergePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mergeDuplicatesApiDuplicatesMergePost>>,
    { data: MergeDuplicatesRequest }
  > = (props) => {
    const { data } = props ?? {};

    return mergeDuplicatesApiDuplicatesMergePost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type MergeDuplicatesApiDuplicatesMergePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof mergeDuplicatesApiDuplicatesMergePost>>
>;
export type MergeDuplicatesApiDuplicatesMergePostMutationBody = MergeDuplicatesRequest;
export type MergeDuplicatesApiDuplicatesMergePostMutationError = HTTPValidationError;

/**
 * @summary Merge Duplicates
 */
export const createMergeDuplicatesApiDuplicatesMergePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof mergeDuplicatesApiDuplicatesMergePost>>,
      TError,
      { data: MergeDuplicatesRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof mergeDuplicatesApiDuplicatesMergePost>>,
  TError,
  { data: MergeDuplicatesRequest },
  TContext
> => {
  const mutationOptions = getMergeDuplicatesApiDuplicatesMergePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generate a summary for a single item
 * @summary Summarize Item
 */
export const summarizeItemApiItemPost = (
  itemSummaryRequest: ItemSummaryRequest,
  params?: SummarizeItemApiItemPostParams,
  signal?: AbortSignal
) => {
  return customInstance<SummaryResponse>({
    url: `/api/item`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: itemSummaryRequest,
    params,
    signal,
  });
};

export const getSummarizeItemApiItemPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof summarizeItemApiItemPost>>,
    TError,
    { data: ItemSummaryRequest; params?: SummarizeItemApiItemPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof summarizeItemApiItemPost>>,
  TError,
  { data: ItemSummaryRequest; params?: SummarizeItemApiItemPostParams },
  TContext
> => {
  const mutationKey = ['summarizeItemApiItemPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof summarizeItemApiItemPost>>,
    { data: ItemSummaryRequest; params?: SummarizeItemApiItemPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return summarizeItemApiItemPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type SummarizeItemApiItemPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof summarizeItemApiItemPost>>
>;
export type SummarizeItemApiItemPostMutationBody = ItemSummaryRequest;
export type SummarizeItemApiItemPostMutationError = HTTPValidationError;

/**
 * @summary Summarize Item
 */
export const createSummarizeItemApiItemPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof summarizeItemApiItemPost>>,
      TError,
      { data: ItemSummaryRequest; params?: SummarizeItemApiItemPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof summarizeItemApiItemPost>>,
  TError,
  { data: ItemSummaryRequest; params?: SummarizeItemApiItemPostParams },
  TContext
> => {
  const mutationOptions = getSummarizeItemApiItemPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generate a content digest for a specific period
 * @summary Generate Digest
 */
export const generateDigestApiDigestPost = (
  digestRequest: DigestRequest,
  params?: GenerateDigestApiDigestPostParams,
  signal?: AbortSignal
) => {
  return customInstance<SummaryResponse>({
    url: `/api/digest`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: digestRequest,
    params,
    signal,
  });
};

export const getGenerateDigestApiDigestPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof generateDigestApiDigestPost>>,
    TError,
    { data: DigestRequest; params?: GenerateDigestApiDigestPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof generateDigestApiDigestPost>>,
  TError,
  { data: DigestRequest; params?: GenerateDigestApiDigestPostParams },
  TContext
> => {
  const mutationKey = ['generateDigestApiDigestPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generateDigestApiDigestPost>>,
    { data: DigestRequest; params?: GenerateDigestApiDigestPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return generateDigestApiDigestPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenerateDigestApiDigestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generateDigestApiDigestPost>>
>;
export type GenerateDigestApiDigestPostMutationBody = DigestRequest;
export type GenerateDigestApiDigestPostMutationError = HTTPValidationError;

/**
 * @summary Generate Digest
 */
export const createGenerateDigestApiDigestPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof generateDigestApiDigestPost>>,
      TError,
      { data: DigestRequest; params?: GenerateDigestApiDigestPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof generateDigestApiDigestPost>>,
  TError,
  { data: DigestRequest; params?: GenerateDigestApiDigestPostParams },
  TContext
> => {
  const mutationOptions = getGenerateDigestApiDigestPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generate a summary for a specific topic
 * @summary Generate Topic Summary
 */
export const generateTopicSummaryApiTopicPost = (
  topicSummaryRequest: TopicSummaryRequest,
  params?: GenerateTopicSummaryApiTopicPostParams,
  signal?: AbortSignal
) => {
  return customInstance<SummaryResponse>({
    url: `/api/topic`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: topicSummaryRequest,
    params,
    signal,
  });
};

export const getGenerateTopicSummaryApiTopicPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof generateTopicSummaryApiTopicPost>>,
    TError,
    { data: TopicSummaryRequest; params?: GenerateTopicSummaryApiTopicPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof generateTopicSummaryApiTopicPost>>,
  TError,
  { data: TopicSummaryRequest; params?: GenerateTopicSummaryApiTopicPostParams },
  TContext
> => {
  const mutationKey = ['generateTopicSummaryApiTopicPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generateTopicSummaryApiTopicPost>>,
    { data: TopicSummaryRequest; params?: GenerateTopicSummaryApiTopicPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return generateTopicSummaryApiTopicPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenerateTopicSummaryApiTopicPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generateTopicSummaryApiTopicPost>>
>;
export type GenerateTopicSummaryApiTopicPostMutationBody = TopicSummaryRequest;
export type GenerateTopicSummaryApiTopicPostMutationError = HTTPValidationError;

/**
 * @summary Generate Topic Summary
 */
export const createGenerateTopicSummaryApiTopicPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof generateTopicSummaryApiTopicPost>>,
      TError,
      { data: TopicSummaryRequest; params?: GenerateTopicSummaryApiTopicPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof generateTopicSummaryApiTopicPost>>,
  TError,
  { data: TopicSummaryRequest; params?: GenerateTopicSummaryApiTopicPostParams },
  TContext
> => {
  const mutationOptions = getGenerateTopicSummaryApiTopicPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generate a custom summary based on filters
 * @summary Generate Custom Summary
 */
export const generateCustomSummaryApiCustomPost = (
  customSummaryRequest: CustomSummaryRequest,
  params?: GenerateCustomSummaryApiCustomPostParams,
  signal?: AbortSignal
) => {
  return customInstance<SummaryResponse>({
    url: `/api/custom`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: customSummaryRequest,
    params,
    signal,
  });
};

export const getGenerateCustomSummaryApiCustomPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof generateCustomSummaryApiCustomPost>>,
    TError,
    { data: CustomSummaryRequest; params?: GenerateCustomSummaryApiCustomPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof generateCustomSummaryApiCustomPost>>,
  TError,
  { data: CustomSummaryRequest; params?: GenerateCustomSummaryApiCustomPostParams },
  TContext
> => {
  const mutationKey = ['generateCustomSummaryApiCustomPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generateCustomSummaryApiCustomPost>>,
    { data: CustomSummaryRequest; params?: GenerateCustomSummaryApiCustomPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return generateCustomSummaryApiCustomPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenerateCustomSummaryApiCustomPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generateCustomSummaryApiCustomPost>>
>;
export type GenerateCustomSummaryApiCustomPostMutationBody = CustomSummaryRequest;
export type GenerateCustomSummaryApiCustomPostMutationError = HTTPValidationError;

/**
 * @summary Generate Custom Summary
 */
export const createGenerateCustomSummaryApiCustomPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof generateCustomSummaryApiCustomPost>>,
      TError,
      { data: CustomSummaryRequest; params?: GenerateCustomSummaryApiCustomPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof generateCustomSummaryApiCustomPost>>,
  TError,
  { data: CustomSummaryRequest; params?: GenerateCustomSummaryApiCustomPostParams },
  TContext
> => {
  const mutationOptions = getGenerateCustomSummaryApiCustomPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Summarize multiple items in batch
 * @summary Batch Summarize
 */
export const batchSummarizeApiBatchPost = (
  batchSummaryRequest: BatchSummaryRequest,
  params?: BatchSummarizeApiBatchPostParams,
  signal?: AbortSignal
) => {
  return customInstance<SummaryResponse>({
    url: `/api/batch`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: batchSummaryRequest,
    params,
    signal,
  });
};

export const getBatchSummarizeApiBatchPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof batchSummarizeApiBatchPost>>,
    TError,
    { data: BatchSummaryRequest; params?: BatchSummarizeApiBatchPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof batchSummarizeApiBatchPost>>,
  TError,
  { data: BatchSummaryRequest; params?: BatchSummarizeApiBatchPostParams },
  TContext
> => {
  const mutationKey = ['batchSummarizeApiBatchPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof batchSummarizeApiBatchPost>>,
    { data: BatchSummaryRequest; params?: BatchSummarizeApiBatchPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return batchSummarizeApiBatchPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type BatchSummarizeApiBatchPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof batchSummarizeApiBatchPost>>
>;
export type BatchSummarizeApiBatchPostMutationBody = BatchSummaryRequest;
export type BatchSummarizeApiBatchPostMutationError = HTTPValidationError;

/**
 * @summary Batch Summarize
 */
export const createBatchSummarizeApiBatchPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof batchSummarizeApiBatchPost>>,
      TError,
      { data: BatchSummaryRequest; params?: BatchSummarizeApiBatchPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof batchSummarizeApiBatchPost>>,
  TError,
  { data: BatchSummaryRequest; params?: BatchSummarizeApiBatchPostParams },
  TContext
> => {
  const mutationOptions = getBatchSummarizeApiBatchPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Preview what would be included in a digest without generating the full summary
 * @summary Preview Digest
 */
export const previewDigestApiDigestPreviewGet = (
  params?: PreviewDigestApiDigestPreviewGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/digest/preview`, method: 'GET', params, signal });
};

export const getPreviewDigestApiDigestPreviewGetQueryKey = (
  params?: PreviewDigestApiDigestPreviewGetParams
) => {
  return [`/api/digest/preview`, ...(params ? [params] : [])] as const;
};

export const getPreviewDigestApiDigestPreviewGetQueryOptions = <
  TData = Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>,
  TError = HTTPValidationError,
>(
  params?: PreviewDigestApiDigestPreviewGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPreviewDigestApiDigestPreviewGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>> = ({
    signal,
  }) => previewDigestApiDigestPreviewGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PreviewDigestApiDigestPreviewGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>
>;
export type PreviewDigestApiDigestPreviewGetQueryError = HTTPValidationError;

/**
 * @summary Preview Digest
 */

export function createPreviewDigestApiDigestPreviewGet<
  TData = Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>,
  TError = HTTPValidationError,
>(
  params?: PreviewDigestApiDigestPreviewGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof previewDigestApiDigestPreviewGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getPreviewDigestApiDigestPreviewGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Basic health check endpoint
 * @summary Health Check
 */
export const healthCheckApiHealthGet = (signal?: AbortSignal) => {
  return customInstance<HealthCheckApiHealthGet200>({ url: `/api/health`, method: 'GET', signal });
};

export const getHealthCheckApiHealthGetQueryKey = () => {
  return [`/api/health`] as const;
};

export const getHealthCheckApiHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckApiHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof healthCheckApiHealthGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckApiHealthGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckApiHealthGet>>> = ({
    signal,
  }) => healthCheckApiHealthGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof healthCheckApiHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckApiHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckApiHealthGet>>
>;
export type HealthCheckApiHealthGetQueryError = unknown;

/**
 * @summary Health Check
 */

export function createHealthCheckApiHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckApiHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof healthCheckApiHealthGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthCheckApiHealthGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Kubernetes liveness probe - checks if service is alive
 * @summary Liveness Probe
 */
export const livenessProbeApiHealthLiveGet = (signal?: AbortSignal) => {
  return customInstance<LivenessProbeApiHealthLiveGet200>({
    url: `/api/health/live`,
    method: 'GET',
    signal,
  });
};

export const getLivenessProbeApiHealthLiveGetQueryKey = () => {
  return [`/api/health/live`] as const;
};

export const getLivenessProbeApiHealthLiveGetQueryOptions = <
  TData = Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLivenessProbeApiHealthLiveGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>> = ({
    signal,
  }) => livenessProbeApiHealthLiveGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LivenessProbeApiHealthLiveGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>
>;
export type LivenessProbeApiHealthLiveGetQueryError = unknown;

/**
 * @summary Liveness Probe
 */

export function createLivenessProbeApiHealthLiveGet<
  TData = Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof livenessProbeApiHealthLiveGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLivenessProbeApiHealthLiveGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Kubernetes readiness probe - checks if service is ready to accept requests
 * @summary Readiness Probe
 */
export const readinessProbeApiHealthReadyGet = (signal?: AbortSignal) => {
  return customInstance<ReadinessProbeApiHealthReadyGet200>({
    url: `/api/health/ready`,
    method: 'GET',
    signal,
  });
};

export const getReadinessProbeApiHealthReadyGetQueryKey = () => {
  return [`/api/health/ready`] as const;
};

export const getReadinessProbeApiHealthReadyGetQueryOptions = <
  TData = Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReadinessProbeApiHealthReadyGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>> = ({
    signal,
  }) => readinessProbeApiHealthReadyGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadinessProbeApiHealthReadyGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>
>;
export type ReadinessProbeApiHealthReadyGetQueryError = unknown;

/**
 * @summary Readiness Probe
 */

export function createReadinessProbeApiHealthReadyGet<
  TData = Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof readinessProbeApiHealthReadyGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getReadinessProbeApiHealthReadyGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Detailed health information for debugging
 * @summary Detailed Health
 */
export const detailedHealthApiHealthDetailedGet = (signal?: AbortSignal) => {
  return customInstance<DetailedHealthApiHealthDetailedGet200>({
    url: `/api/health/detailed`,
    method: 'GET',
    signal,
  });
};

export const getDetailedHealthApiHealthDetailedGetQueryKey = () => {
  return [`/api/health/detailed`] as const;
};

export const getDetailedHealthApiHealthDetailedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDetailedHealthApiHealthDetailedGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>> = ({
    signal,
  }) => detailedHealthApiHealthDetailedGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DetailedHealthApiHealthDetailedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>
>;
export type DetailedHealthApiHealthDetailedGetQueryError = unknown;

/**
 * @summary Detailed Health
 */

export function createDetailedHealthApiHealthDetailedGet<
  TData = Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof detailedHealthApiHealthDetailedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDetailedHealthApiHealthDetailedGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Generate dynamic insights about the knowledge base
 * @summary Get Insights
 */
export const getInsightsApiInsightsGet = (
  params?: GetInsightsApiInsightsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<InsightsResponse>({ url: `/api/insights`, method: 'GET', params, signal });
};

export const getGetInsightsApiInsightsGetQueryKey = (params?: GetInsightsApiInsightsGetParams) => {
  return [`/api/insights`, ...(params ? [params] : [])] as const;
};

export const getGetInsightsApiInsightsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInsightsApiInsightsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetInsightsApiInsightsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getInsightsApiInsightsGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInsightsApiInsightsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInsightsApiInsightsGet>>> = ({
    signal,
  }) => getInsightsApiInsightsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getInsightsApiInsightsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInsightsApiInsightsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInsightsApiInsightsGet>>
>;
export type GetInsightsApiInsightsGetQueryError = HTTPValidationError;

/**
 * @summary Get Insights
 */

export function createGetInsightsApiInsightsGet<
  TData = Awaited<ReturnType<typeof getInsightsApiInsightsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetInsightsApiInsightsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getInsightsApiInsightsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInsightsApiInsightsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get available insight types
 * @summary Get Insight Types
 */
export const getInsightTypesApiInsightsTypesGet = (signal?: AbortSignal) => {
  return customInstance<InsightTypeInfo[]>({ url: `/api/insights/types`, method: 'GET', signal });
};

export const getGetInsightTypesApiInsightsTypesGetQueryKey = () => {
  return [`/api/insights/types`] as const;
};

export const getGetInsightTypesApiInsightsTypesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInsightTypesApiInsightsTypesGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>> = ({
    signal,
  }) => getInsightTypesApiInsightsTypesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInsightTypesApiInsightsTypesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>
>;
export type GetInsightTypesApiInsightsTypesGetQueryError = unknown;

/**
 * @summary Get Insight Types
 */

export function createGetInsightTypesApiInsightsTypesGet<
  TData = Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getInsightTypesApiInsightsTypesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInsightTypesApiInsightsTypesGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get just trending topics (lightweight endpoint)
 * @summary Get Trending Insights
 */
export const getTrendingInsightsApiInsightsTrendingGet = (
  params?: GetTrendingInsightsApiInsightsTrendingGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/insights/trending`, method: 'GET', params, signal });
};

export const getGetTrendingInsightsApiInsightsTrendingGetQueryKey = (
  params?: GetTrendingInsightsApiInsightsTrendingGetParams
) => {
  return [`/api/insights/trending`, ...(params ? [params] : [])] as const;
};

export const getGetTrendingInsightsApiInsightsTrendingGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTrendingInsightsApiInsightsTrendingGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTrendingInsightsApiInsightsTrendingGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>
  > = ({ signal }) => getTrendingInsightsApiInsightsTrendingGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTrendingInsightsApiInsightsTrendingGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>
>;
export type GetTrendingInsightsApiInsightsTrendingGetQueryError = HTTPValidationError;

/**
 * @summary Get Trending Insights
 */

export function createGetTrendingInsightsApiInsightsTrendingGet<
  TData = Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTrendingInsightsApiInsightsTrendingGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTrendingInsightsApiInsightsTrendingGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTrendingInsightsApiInsightsTrendingGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get learning velocity metrics
 * @summary Get Learning Velocity
 */
export const getLearningVelocityApiInsightsLearningVelocityGet = (
  params?: GetLearningVelocityApiInsightsLearningVelocityGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/insights/learning-velocity`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetLearningVelocityApiInsightsLearningVelocityGetQueryKey = (
  params?: GetLearningVelocityApiInsightsLearningVelocityGetParams
) => {
  return [`/api/insights/learning-velocity`, ...(params ? [params] : [])] as const;
};

export const getGetLearningVelocityApiInsightsLearningVelocityGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLearningVelocityApiInsightsLearningVelocityGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLearningVelocityApiInsightsLearningVelocityGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>
  > = ({ signal }) => getLearningVelocityApiInsightsLearningVelocityGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLearningVelocityApiInsightsLearningVelocityGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>
>;
export type GetLearningVelocityApiInsightsLearningVelocityGetQueryError = HTTPValidationError;

/**
 * @summary Get Learning Velocity
 */

export function createGetLearningVelocityApiInsightsLearningVelocityGet<
  TData = Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>,
  TError = HTTPValidationError,
>(
  params?: GetLearningVelocityApiInsightsLearningVelocityGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getLearningVelocityApiInsightsLearningVelocityGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetLearningVelocityApiInsightsLearningVelocityGetQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get personalized exploration suggestions
 * @summary Get Exploration Suggestions
 */
export const getExplorationSuggestionsApiInsightsExplorationSuggestionsGet = (
  params?: GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/insights/exploration-suggestions`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetExplorationSuggestionsApiInsightsExplorationSuggestionsGetQueryKey = (
  params?: GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetParams
) => {
  return [`/api/insights/exploration-suggestions`, ...(params ? [params] : [])] as const;
};

export const getGetExplorationSuggestionsApiInsightsExplorationSuggestionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetExplorationSuggestionsApiInsightsExplorationSuggestionsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>
  > = ({ signal }) => getExplorationSuggestionsApiInsightsExplorationSuggestionsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>
>;
export type GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Exploration Suggestions
 */

export function createGetExplorationSuggestionsApiInsightsExplorationSuggestionsGet<
  TData = Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetExplorationSuggestionsApiInsightsExplorationSuggestionsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getExplorationSuggestionsApiInsightsExplorationSuggestionsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExplorationSuggestionsApiInsightsExplorationSuggestionsGetQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get insights optimized for dashboard display
 * @summary Get Dashboard Insights
 */
export const getDashboardInsightsApiInsightsDashboardGet = (
  params?: GetDashboardInsightsApiInsightsDashboardGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/insights/dashboard`, method: 'GET', params, signal });
};

export const getGetDashboardInsightsApiInsightsDashboardGetQueryKey = (
  params?: GetDashboardInsightsApiInsightsDashboardGetParams
) => {
  return [`/api/insights/dashboard`, ...(params ? [params] : [])] as const;
};

export const getGetDashboardInsightsApiInsightsDashboardGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDashboardInsightsApiInsightsDashboardGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDashboardInsightsApiInsightsDashboardGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>
  > = ({ signal }) => getDashboardInsightsApiInsightsDashboardGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDashboardInsightsApiInsightsDashboardGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>
>;
export type GetDashboardInsightsApiInsightsDashboardGetQueryError = HTTPValidationError;

/**
 * @summary Get Dashboard Insights
 */

export function createGetDashboardInsightsApiInsightsDashboardGet<
  TData = Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDashboardInsightsApiInsightsDashboardGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getDashboardInsightsApiInsightsDashboardGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDashboardInsightsApiInsightsDashboardGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get daily content type counts for timeline trends visualization
 * @summary Get Timeline Trends
 */
export const getTimelineTrendsApiInsightsTimelineTrendsGet = (
  params?: GetTimelineTrendsApiInsightsTimelineTrendsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/insights/timeline-trends`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetTimelineTrendsApiInsightsTimelineTrendsGetQueryKey = (
  params?: GetTimelineTrendsApiInsightsTimelineTrendsGetParams
) => {
  return [`/api/insights/timeline-trends`, ...(params ? [params] : [])] as const;
};

export const getGetTimelineTrendsApiInsightsTimelineTrendsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTimelineTrendsApiInsightsTimelineTrendsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimelineTrendsApiInsightsTimelineTrendsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>
  > = ({ signal }) => getTimelineTrendsApiInsightsTimelineTrendsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineTrendsApiInsightsTimelineTrendsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>
>;
export type GetTimelineTrendsApiInsightsTimelineTrendsGetQueryError = HTTPValidationError;

/**
 * @summary Get Timeline Trends
 */

export function createGetTimelineTrendsApiInsightsTimelineTrendsGet<
  TData = Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTimelineTrendsApiInsightsTimelineTrendsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTimelineTrendsApiInsightsTimelineTrendsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTimelineTrendsApiInsightsTimelineTrendsGetQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get top tags with usage counts for Memory Palace visualization
 * @summary Get Top Tags
 */
export const getTopTagsApiInsightsTopTagsGet = (
  params?: GetTopTagsApiInsightsTopTagsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/insights/top-tags`, method: 'GET', params, signal });
};

export const getGetTopTagsApiInsightsTopTagsGetQueryKey = (
  params?: GetTopTagsApiInsightsTopTagsGetParams
) => {
  return [`/api/insights/top-tags`, ...(params ? [params] : [])] as const;
};

export const getGetTopTagsApiInsightsTopTagsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTopTagsApiInsightsTopTagsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTopTagsApiInsightsTopTagsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>> = ({
    signal,
  }) => getTopTagsApiInsightsTopTagsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTopTagsApiInsightsTopTagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>
>;
export type GetTopTagsApiInsightsTopTagsGetQueryError = HTTPValidationError;

/**
 * @summary Get Top Tags
 */

export function createGetTopTagsApiInsightsTopTagsGet<
  TData = Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTopTagsApiInsightsTopTagsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getTopTagsApiInsightsTopTagsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTopTagsApiInsightsTopTagsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Analyze user's content and tags to determine personality type
 * @summary Get Personality Analysis
 */
export const getPersonalityAnalysisApiInsightsPersonalityAnalysisGet = (
  params?: GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/insights/personality-analysis`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetPersonalityAnalysisApiInsightsPersonalityAnalysisGetQueryKey = (
  params?: GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetParams
) => {
  return [`/api/insights/personality-analysis`, ...(params ? [params] : [])] as const;
};

export const getGetPersonalityAnalysisApiInsightsPersonalityAnalysisGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPersonalityAnalysisApiInsightsPersonalityAnalysisGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>
  > = ({ signal }) => getPersonalityAnalysisApiInsightsPersonalityAnalysisGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>
>;
export type GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetQueryError = HTTPValidationError;

/**
 * @summary Get Personality Analysis
 */

export function createGetPersonalityAnalysisApiInsightsPersonalityAnalysisGet<
  TData = Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>,
  TError = HTTPValidationError,
>(
  params?: GetPersonalityAnalysisApiInsightsPersonalityAnalysisGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getPersonalityAnalysisApiInsightsPersonalityAnalysisGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPersonalityAnalysisApiInsightsPersonalityAnalysisGetQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get top-rated content for Memory Palace visualization
 * @summary Get Top Content
 */
export const getTopContentApiInsightsTopContentGet = (
  params?: GetTopContentApiInsightsTopContentGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/insights/top-content`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetTopContentApiInsightsTopContentGetQueryKey = (
  params?: GetTopContentApiInsightsTopContentGetParams
) => {
  return [`/api/insights/top-content`, ...(params ? [params] : [])] as const;
};

export const getGetTopContentApiInsightsTopContentGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTopContentApiInsightsTopContentGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTopContentApiInsightsTopContentGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>
  > = ({ signal }) => getTopContentApiInsightsTopContentGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTopContentApiInsightsTopContentGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>
>;
export type GetTopContentApiInsightsTopContentGetQueryError = HTTPValidationError;

/**
 * @summary Get Top Content
 */

export function createGetTopContentApiInsightsTopContentGet<
  TData = Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>,
  TError = HTTPValidationError,
>(
  params?: GetTopContentApiInsightsTopContentGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getTopContentApiInsightsTopContentGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTopContentApiInsightsTopContentGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get available import options and endpoints
 * @summary Get Import Options
 */
export const getImportOptionsApiImportGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/import/`, method: 'GET', signal });
};

export const getGetImportOptionsApiImportGetQueryKey = () => {
  return [`/api/import/`] as const;
};

export const getGetImportOptionsApiImportGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getImportOptionsApiImportGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof getImportOptionsApiImportGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImportOptionsApiImportGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImportOptionsApiImportGet>>> = ({
    signal,
  }) => getImportOptionsApiImportGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getImportOptionsApiImportGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetImportOptionsApiImportGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getImportOptionsApiImportGet>>
>;
export type GetImportOptionsApiImportGetQueryError = unknown;

/**
 * @summary Get Import Options
 */

export function createGetImportOptionsApiImportGet<
  TData = Awaited<ReturnType<typeof getImportOptionsApiImportGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getImportOptionsApiImportGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetImportOptionsApiImportGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Import items from PRSNL JSON export
 * @summary Import Json
 */
export const importJsonApiImportJsonPost = (
  bodyImportJsonApiImportJsonPost: BodyImportJsonApiImportJsonPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`file`, bodyImportJsonApiImportJsonPost.file);
  if (bodyImportJsonApiImportJsonPost.merge_duplicates !== undefined) {
    formData.append(
      `merge_duplicates`,
      bodyImportJsonApiImportJsonPost.merge_duplicates.toString()
    );
  }

  return customInstance<unknown>({
    url: `/api/import/json`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getImportJsonApiImportJsonPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof importJsonApiImportJsonPost>>,
    TError,
    { data: BodyImportJsonApiImportJsonPost },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof importJsonApiImportJsonPost>>,
  TError,
  { data: BodyImportJsonApiImportJsonPost },
  TContext
> => {
  const mutationKey = ['importJsonApiImportJsonPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importJsonApiImportJsonPost>>,
    { data: BodyImportJsonApiImportJsonPost }
  > = (props) => {
    const { data } = props ?? {};

    return importJsonApiImportJsonPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportJsonApiImportJsonPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importJsonApiImportJsonPost>>
>;
export type ImportJsonApiImportJsonPostMutationBody = BodyImportJsonApiImportJsonPost;
export type ImportJsonApiImportJsonPostMutationError = HTTPValidationError;

/**
 * @summary Import Json
 */
export const createImportJsonApiImportJsonPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof importJsonApiImportJsonPost>>,
      TError,
      { data: BodyImportJsonApiImportJsonPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof importJsonApiImportJsonPost>>,
  TError,
  { data: BodyImportJsonApiImportJsonPost },
  TContext
> => {
  const mutationOptions = getImportJsonApiImportJsonPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Import bookmarks from browser HTML export with batched processing
 * @summary Import Bookmarks
 */
export const importBookmarksApiImportBookmarksPost = (
  bodyImportBookmarksApiImportBookmarksPost: BodyImportBookmarksApiImportBookmarksPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`file`, bodyImportBookmarksApiImportBookmarksPost.file);
  if (bodyImportBookmarksApiImportBookmarksPost.auto_fetch !== undefined) {
    formData.append(`auto_fetch`, bodyImportBookmarksApiImportBookmarksPost.auto_fetch.toString());
  }
  if (bodyImportBookmarksApiImportBookmarksPost.batch_size !== undefined) {
    formData.append(`batch_size`, bodyImportBookmarksApiImportBookmarksPost.batch_size.toString());
  }

  return customInstance<unknown>({
    url: `/api/import/bookmarks`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getImportBookmarksApiImportBookmarksPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof importBookmarksApiImportBookmarksPost>>,
    TError,
    { data: BodyImportBookmarksApiImportBookmarksPost },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof importBookmarksApiImportBookmarksPost>>,
  TError,
  { data: BodyImportBookmarksApiImportBookmarksPost },
  TContext
> => {
  const mutationKey = ['importBookmarksApiImportBookmarksPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importBookmarksApiImportBookmarksPost>>,
    { data: BodyImportBookmarksApiImportBookmarksPost }
  > = (props) => {
    const { data } = props ?? {};

    return importBookmarksApiImportBookmarksPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportBookmarksApiImportBookmarksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importBookmarksApiImportBookmarksPost>>
>;
export type ImportBookmarksApiImportBookmarksPostMutationBody =
  BodyImportBookmarksApiImportBookmarksPost;
export type ImportBookmarksApiImportBookmarksPostMutationError = HTTPValidationError;

/**
 * @summary Import Bookmarks
 */
export const createImportBookmarksApiImportBookmarksPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof importBookmarksApiImportBookmarksPost>>,
      TError,
      { data: BodyImportBookmarksApiImportBookmarksPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof importBookmarksApiImportBookmarksPost>>,
  TError,
  { data: BodyImportBookmarksApiImportBookmarksPost },
  TContext
> => {
  const mutationOptions = getImportBookmarksApiImportBookmarksPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Import notes from text files (Markdown, Plain text, etc.)
 * @summary Import Notes
 */
export const importNotesApiImportNotesPost = (
  bodyImportNotesApiImportNotesPost: BodyImportNotesApiImportNotesPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`file`, bodyImportNotesApiImportNotesPost.file);
  if (bodyImportNotesApiImportNotesPost.format !== undefined) {
    formData.append(`format`, bodyImportNotesApiImportNotesPost.format);
  }
  if (
    bodyImportNotesApiImportNotesPost.default_tags !== undefined &&
    bodyImportNotesApiImportNotesPost.default_tags !== null
  ) {
    formData.append(`default_tags`, bodyImportNotesApiImportNotesPost.default_tags);
  }

  return customInstance<unknown>({
    url: `/api/import/notes`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getImportNotesApiImportNotesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof importNotesApiImportNotesPost>>,
    TError,
    { data: BodyImportNotesApiImportNotesPost },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof importNotesApiImportNotesPost>>,
  TError,
  { data: BodyImportNotesApiImportNotesPost },
  TContext
> => {
  const mutationKey = ['importNotesApiImportNotesPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importNotesApiImportNotesPost>>,
    { data: BodyImportNotesApiImportNotesPost }
  > = (props) => {
    const { data } = props ?? {};

    return importNotesApiImportNotesPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportNotesApiImportNotesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importNotesApiImportNotesPost>>
>;
export type ImportNotesApiImportNotesPostMutationBody = BodyImportNotesApiImportNotesPost;
export type ImportNotesApiImportNotesPostMutationError = HTTPValidationError;

/**
 * @summary Import Notes
 */
export const createImportNotesApiImportNotesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof importNotesApiImportNotesPost>>,
      TError,
      { data: BodyImportNotesApiImportNotesPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof importNotesApiImportNotesPost>>,
  TError,
  { data: BodyImportNotesApiImportNotesPost },
  TContext
> => {
  const mutationOptions = getImportNotesApiImportNotesPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Import multiple URLs in bulk - optimized for speed
 * @summary Import Bulk Urls
 */
export const importBulkUrlsApiImportUrlsBulkPost = (
  bulkURLRequest: BulkURLRequest,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/import/urls/bulk`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bulkURLRequest,
    signal,
  });
};

export const getImportBulkUrlsApiImportUrlsBulkPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof importBulkUrlsApiImportUrlsBulkPost>>,
    TError,
    { data: BulkURLRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof importBulkUrlsApiImportUrlsBulkPost>>,
  TError,
  { data: BulkURLRequest },
  TContext
> => {
  const mutationKey = ['importBulkUrlsApiImportUrlsBulkPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof importBulkUrlsApiImportUrlsBulkPost>>,
    { data: BulkURLRequest }
  > = (props) => {
    const { data } = props ?? {};

    return importBulkUrlsApiImportUrlsBulkPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImportBulkUrlsApiImportUrlsBulkPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof importBulkUrlsApiImportUrlsBulkPost>>
>;
export type ImportBulkUrlsApiImportUrlsBulkPostMutationBody = BulkURLRequest;
export type ImportBulkUrlsApiImportUrlsBulkPostMutationError = HTTPValidationError;

/**
 * @summary Import Bulk Urls
 */
export const createImportBulkUrlsApiImportUrlsBulkPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof importBulkUrlsApiImportUrlsBulkPost>>,
      TError,
      { data: BulkURLRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof importBulkUrlsApiImportUrlsBulkPost>>,
  TError,
  { data: BulkURLRequest },
  TContext
> => {
  const mutationOptions = getImportBulkUrlsApiImportUrlsBulkPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Backward compatibility redirect to import endpoints
 * @summary Import Data Alias
 */
export const importDataAliasApiImportDataGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/import-data`, method: 'GET', signal });
};

export const getImportDataAliasApiImportDataGetQueryKey = () => {
  return [`/api/import-data`] as const;
};

export const getImportDataAliasApiImportDataGetQueryOptions = <
  TData = Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImportDataAliasApiImportDataGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>> = ({
    signal,
  }) => importDataAliasApiImportDataGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImportDataAliasApiImportDataGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>
>;
export type ImportDataAliasApiImportDataGetQueryError = unknown;

/**
 * @summary Import Data Alias
 */

export function createImportDataAliasApiImportDataGet<
  TData = Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof importDataAliasApiImportDataGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getImportDataAliasApiImportDataGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Upload and process files

Args:
    files: The uploaded files
    url: Optional URL 
    title: Optional title for the item
    highlight: Optional highlight text
    content_type: Content type classification
    enable_summarization: Whether to enable AI summarization
    tags: JSON string of tags
    db_connection: Database connection
 * @summary Upload File
 */
export const uploadFileApiFileUploadPost = (
  bodyUploadFileApiFileUploadPost: BodyUploadFileApiFileUploadPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  bodyUploadFileApiFileUploadPost.files.forEach((value) => formData.append(`files`, value));
  if (
    bodyUploadFileApiFileUploadPost.url !== undefined &&
    bodyUploadFileApiFileUploadPost.url !== null
  ) {
    formData.append(`url`, bodyUploadFileApiFileUploadPost.url);
  }
  if (
    bodyUploadFileApiFileUploadPost.title !== undefined &&
    bodyUploadFileApiFileUploadPost.title !== null
  ) {
    formData.append(`title`, bodyUploadFileApiFileUploadPost.title);
  }
  if (
    bodyUploadFileApiFileUploadPost.highlight !== undefined &&
    bodyUploadFileApiFileUploadPost.highlight !== null
  ) {
    formData.append(`highlight`, bodyUploadFileApiFileUploadPost.highlight);
  }
  if (bodyUploadFileApiFileUploadPost.content_type !== undefined) {
    formData.append(`content_type`, bodyUploadFileApiFileUploadPost.content_type);
  }
  if (bodyUploadFileApiFileUploadPost.enable_summarization !== undefined) {
    formData.append(
      `enable_summarization`,
      bodyUploadFileApiFileUploadPost.enable_summarization.toString()
    );
  }
  if (
    bodyUploadFileApiFileUploadPost.tags !== undefined &&
    bodyUploadFileApiFileUploadPost.tags !== null
  ) {
    formData.append(`tags`, bodyUploadFileApiFileUploadPost.tags);
  }

  return customInstance<FileUploadResponse>({
    url: `/api/file/upload`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadFileApiFileUploadPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof uploadFileApiFileUploadPost>>,
    TError,
    { data: BodyUploadFileApiFileUploadPost },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof uploadFileApiFileUploadPost>>,
  TError,
  { data: BodyUploadFileApiFileUploadPost },
  TContext
> => {
  const mutationKey = ['uploadFileApiFileUploadPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFileApiFileUploadPost>>,
    { data: BodyUploadFileApiFileUploadPost }
  > = (props) => {
    const { data } = props ?? {};

    return uploadFileApiFileUploadPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadFileApiFileUploadPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadFileApiFileUploadPost>>
>;
export type UploadFileApiFileUploadPostMutationBody = BodyUploadFileApiFileUploadPost;
export type UploadFileApiFileUploadPostMutationError = HTTPValidationError;

/**
 * @summary Upload File
 */
export const createUploadFileApiFileUploadPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof uploadFileApiFileUploadPost>>,
      TError,
      { data: BodyUploadFileApiFileUploadPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof uploadFileApiFileUploadPost>>,
  TError,
  { data: BodyUploadFileApiFileUploadPost },
  TContext
> => {
  const mutationOptions = getUploadFileApiFileUploadPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get processing status for a file
 * @summary Get File Processing Status
 */
export const getFileProcessingStatusApiFileStatusFileIdGet = (
  fileId: string,
  signal?: AbortSignal
) => {
  return customInstance<FileProcessingStatus>({
    url: `/api/file/status/${fileId}`,
    method: 'GET',
    signal,
  });
};

export const getGetFileProcessingStatusApiFileStatusFileIdGetQueryKey = (fileId: string) => {
  return [`/api/file/status/${fileId}`] as const;
};

export const getGetFileProcessingStatusApiFileStatusFileIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>,
  TError = HTTPValidationError,
>(
  fileId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileProcessingStatusApiFileStatusFileIdGetQueryKey(fileId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>
  > = ({ signal }) => getFileProcessingStatusApiFileStatusFileIdGet(fileId, signal);

  return { queryKey, queryFn, enabled: !!fileId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileProcessingStatusApiFileStatusFileIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>
>;
export type GetFileProcessingStatusApiFileStatusFileIdGetQueryError = HTTPValidationError;

/**
 * @summary Get File Processing Status
 */

export function createGetFileProcessingStatusApiFileStatusFileIdGet<
  TData = Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>,
  TError = HTTPValidationError,
>(
  fileId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getFileProcessingStatusApiFileStatusFileIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFileProcessingStatusApiFileStatusFileIdGetQueryOptions(
    fileId,
    options
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get file content and metadata
 * @summary Get File Content
 */
export const getFileContentApiFileContentFileIdGet = (fileId: string, signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/file/content/${fileId}`, method: 'GET', signal });
};

export const getGetFileContentApiFileContentFileIdGetQueryKey = (fileId: string) => {
  return [`/api/file/content/${fileId}`] as const;
};

export const getGetFileContentApiFileContentFileIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>,
  TError = HTTPValidationError,
>(
  fileId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileContentApiFileContentFileIdGetQueryKey(fileId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>
  > = ({ signal }) => getFileContentApiFileContentFileIdGet(fileId, signal);

  return { queryKey, queryFn, enabled: !!fileId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileContentApiFileContentFileIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>
>;
export type GetFileContentApiFileContentFileIdGetQueryError = HTTPValidationError;

/**
 * @summary Get File Content
 */

export function createGetFileContentApiFileContentFileIdGet<
  TData = Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>,
  TError = HTTPValidationError,
>(
  fileId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getFileContentApiFileContentFileIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFileContentApiFileContentFileIdGetQueryOptions(fileId, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a file and its associated item
 * @summary Delete File
 */
export const deleteFileApiFileFileIdDelete = (fileId: string) => {
  return customInstance<unknown>({ url: `/api/file/${fileId}`, method: 'DELETE' });
};

export const getDeleteFileApiFileFileIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof deleteFileApiFileFileIdDelete>>,
    TError,
    { fileId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof deleteFileApiFileFileIdDelete>>,
  TError,
  { fileId: string },
  TContext
> => {
  const mutationKey = ['deleteFileApiFileFileIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFileApiFileFileIdDelete>>,
    { fileId: string }
  > = (props) => {
    const { fileId } = props ?? {};

    return deleteFileApiFileFileIdDelete(fileId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteFileApiFileFileIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFileApiFileFileIdDelete>>
>;

export type DeleteFileApiFileFileIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete File
 */
export const createDeleteFileApiFileFileIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof deleteFileApiFileFileIdDelete>>,
      TError,
      { fileId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof deleteFileApiFileFileIdDelete>>,
  TError,
  { fileId: string },
  TContext
> => {
  const mutationOptions = getDeleteFileApiFileFileIdDeleteMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get file storage and processing statistics
 * @summary Get File Stats
 */
export const getFileStatsApiFileStatsGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/file/stats`, method: 'GET', signal });
};

export const getGetFileStatsApiFileStatsGetQueryKey = () => {
  return [`/api/file/stats`] as const;
};

export const getGetFileStatsApiFileStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFileStatsApiFileStatsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>> = ({
    signal,
  }) => getFileStatsApiFileStatsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileStatsApiFileStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>
>;
export type GetFileStatsApiFileStatsGetQueryError = unknown;

/**
 * @summary Get File Stats
 */

export function createGetFileStatsApiFileStatsGet<
  TData = Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getFileStatsApiFileStatsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFileStatsApiFileStatsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all available content types with their metadata.
 * @summary Get Content Types
 */
export const getContentTypesApiContentTypesGet = (signal?: AbortSignal) => {
  return customInstance<GetContentTypesApiContentTypesGet200>({
    url: `/api/content-types`,
    method: 'GET',
    signal,
  });
};

export const getGetContentTypesApiContentTypesGetQueryKey = () => {
  return [`/api/content-types`] as const;
};

export const getGetContentTypesApiContentTypesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetContentTypesApiContentTypesGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>> = ({
    signal,
  }) => getContentTypesApiContentTypesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetContentTypesApiContentTypesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>
>;
export type GetContentTypesApiContentTypesGetQueryError = unknown;

/**
 * @summary Get Content Types
 */

export function createGetContentTypesApiContentTypesGet<
  TData = Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getContentTypesApiContentTypesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetContentTypesApiContentTypesGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get metadata for a specific content type.
 * @summary Get Content Type
 */
export const getContentTypeApiContentTypesTypeNameGet = (
  typeName: string,
  signal?: AbortSignal
) => {
  return customInstance<GetContentTypeApiContentTypesTypeNameGet200>({
    url: `/api/content-types/${typeName}`,
    method: 'GET',
    signal,
  });
};

export const getGetContentTypeApiContentTypesTypeNameGetQueryKey = (typeName: string) => {
  return [`/api/content-types/${typeName}`] as const;
};

export const getGetContentTypeApiContentTypesTypeNameGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>,
  TError = HTTPValidationError,
>(
  typeName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetContentTypeApiContentTypesTypeNameGetQueryKey(typeName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>
  > = ({ signal }) => getContentTypeApiContentTypesTypeNameGet(typeName, signal);

  return { queryKey, queryFn, enabled: !!typeName, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetContentTypeApiContentTypesTypeNameGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>
>;
export type GetContentTypeApiContentTypesTypeNameGetQueryError = HTTPValidationError;

/**
 * @summary Get Content Type
 */

export function createGetContentTypeApiContentTypesTypeNameGet<
  TData = Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>,
  TError = HTTPValidationError,
>(
  typeName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getContentTypeApiContentTypesTypeNameGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetContentTypeApiContentTypesTypeNameGetQueryOptions(typeName, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all development categories with item counts
 * @summary Get Development Categories
 */
export const getDevelopmentCategoriesApiDevelopmentCategoriesGet = (signal?: AbortSignal) => {
  return customInstance<DevelopmentCategory[]>({
    url: `/api/development/categories`,
    method: 'GET',
    signal,
  });
};

export const getGetDevelopmentCategoriesApiDevelopmentCategoriesGetQueryKey = () => {
  return [`/api/development/categories`] as const;
};

export const getGetDevelopmentCategoriesApiDevelopmentCategoriesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDevelopmentCategoriesApiDevelopmentCategoriesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>
  > = ({ signal }) => getDevelopmentCategoriesApiDevelopmentCategoriesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDevelopmentCategoriesApiDevelopmentCategoriesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>
>;
export type GetDevelopmentCategoriesApiDevelopmentCategoriesGetQueryError = unknown;

/**
 * @summary Get Development Categories
 */

export function createGetDevelopmentCategoriesApiDevelopmentCategoriesGet<
  TData = Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getDevelopmentCategoriesApiDevelopmentCategoriesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDevelopmentCategoriesApiDevelopmentCategoriesGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all programming languages found in development content
 * @summary Get Programming Languages
 */
export const getProgrammingLanguagesApiDevelopmentLanguagesGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/development/languages`, method: 'GET', signal });
};

export const getGetProgrammingLanguagesApiDevelopmentLanguagesGetQueryKey = () => {
  return [`/api/development/languages`] as const;
};

export const getGetProgrammingLanguagesApiDevelopmentLanguagesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgrammingLanguagesApiDevelopmentLanguagesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>
  > = ({ signal }) => getProgrammingLanguagesApiDevelopmentLanguagesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgrammingLanguagesApiDevelopmentLanguagesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>
>;
export type GetProgrammingLanguagesApiDevelopmentLanguagesGetQueryError = unknown;

/**
 * @summary Get Programming Languages
 */

export function createGetProgrammingLanguagesApiDevelopmentLanguagesGet<
  TData = Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getProgrammingLanguagesApiDevelopmentLanguagesGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetProgrammingLanguagesApiDevelopmentLanguagesGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get development documents with advanced filtering
 * @summary Get Development Docs
 */
export const getDevelopmentDocsApiDevelopmentDocsGet = (
  params?: GetDevelopmentDocsApiDevelopmentDocsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<DevelopmentItem[]>({
    url: `/api/development/docs`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetDevelopmentDocsApiDevelopmentDocsGetQueryKey = (
  params?: GetDevelopmentDocsApiDevelopmentDocsGetParams
) => {
  return [`/api/development/docs`, ...(params ? [params] : [])] as const;
};

export const getGetDevelopmentDocsApiDevelopmentDocsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDevelopmentDocsApiDevelopmentDocsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDevelopmentDocsApiDevelopmentDocsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>
  > = ({ signal }) => getDevelopmentDocsApiDevelopmentDocsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDevelopmentDocsApiDevelopmentDocsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>
>;
export type GetDevelopmentDocsApiDevelopmentDocsGetQueryError = HTTPValidationError;

/**
 * @summary Get Development Docs
 */

export function createGetDevelopmentDocsApiDevelopmentDocsGet<
  TData = Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetDevelopmentDocsApiDevelopmentDocsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getDevelopmentDocsApiDevelopmentDocsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDevelopmentDocsApiDevelopmentDocsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get development content statistics
 * @summary Get Development Stats
 */
export const getDevelopmentStatsApiDevelopmentStatsGet = (signal?: AbortSignal) => {
  return customInstance<DevelopmentStats>({ url: `/api/development/stats`, method: 'GET', signal });
};

export const getGetDevelopmentStatsApiDevelopmentStatsGetQueryKey = () => {
  return [`/api/development/stats`] as const;
};

export const getGetDevelopmentStatsApiDevelopmentStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDevelopmentStatsApiDevelopmentStatsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>
  > = ({ signal }) => getDevelopmentStatsApiDevelopmentStatsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDevelopmentStatsApiDevelopmentStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>
>;
export type GetDevelopmentStatsApiDevelopmentStatsGetQueryError = unknown;

/**
 * @summary Get Development Stats
 */

export function createGetDevelopmentStatsApiDevelopmentStatsGet<
  TData = Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getDevelopmentStatsApiDevelopmentStatsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDevelopmentStatsApiDevelopmentStatsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Save a code snippet as development content
 * @summary Save Code Snippet
 */
export const saveCodeSnippetApiDevelopmentSnippetPost = (
  codeSnippet: CodeSnippet,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/development/snippet`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: codeSnippet,
    signal,
  });
};

export const getSaveCodeSnippetApiDevelopmentSnippetPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof saveCodeSnippetApiDevelopmentSnippetPost>>,
    TError,
    { data: CodeSnippet },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof saveCodeSnippetApiDevelopmentSnippetPost>>,
  TError,
  { data: CodeSnippet },
  TContext
> => {
  const mutationKey = ['saveCodeSnippetApiDevelopmentSnippetPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveCodeSnippetApiDevelopmentSnippetPost>>,
    { data: CodeSnippet }
  > = (props) => {
    const { data } = props ?? {};

    return saveCodeSnippetApiDevelopmentSnippetPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveCodeSnippetApiDevelopmentSnippetPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveCodeSnippetApiDevelopmentSnippetPost>>
>;
export type SaveCodeSnippetApiDevelopmentSnippetPostMutationBody = CodeSnippet;
export type SaveCodeSnippetApiDevelopmentSnippetPostMutationError = HTTPValidationError;

/**
 * @summary Save Code Snippet
 */
export const createSaveCodeSnippetApiDevelopmentSnippetPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof saveCodeSnippetApiDevelopmentSnippetPost>>,
      TError,
      { data: CodeSnippet },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof saveCodeSnippetApiDevelopmentSnippetPost>>,
  TError,
  { data: CodeSnippet },
  TContext
> => {
  const mutationOptions = getSaveCodeSnippetApiDevelopmentSnippetPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get all learning paths with progress
 * @summary Get Learning Paths
 */
export const getLearningPathsApiDevelopmentLearningPathsGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/development/learning-paths`, method: 'GET', signal });
};

export const getGetLearningPathsApiDevelopmentLearningPathsGetQueryKey = () => {
  return [`/api/development/learning-paths`] as const;
};

export const getGetLearningPathsApiDevelopmentLearningPathsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLearningPathsApiDevelopmentLearningPathsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>
  > = ({ signal }) => getLearningPathsApiDevelopmentLearningPathsGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLearningPathsApiDevelopmentLearningPathsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>
>;
export type GetLearningPathsApiDevelopmentLearningPathsGetQueryError = unknown;

/**
 * @summary Get Learning Paths
 */

export function createGetLearningPathsApiDevelopmentLearningPathsGet<
  TData = Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getLearningPathsApiDevelopmentLearningPathsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetLearningPathsApiDevelopmentLearningPathsGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Auto-categorize development content using AI analysis
 * @summary Auto Categorize Development Content
 */
export const autoCategorizeDevelopmentContentApiDevelopmentCategorizePost = (
  params: AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({
    url: `/api/development/categorize`,
    method: 'POST',
    params,
    signal,
  });
};

export const getAutoCategorizeDevelopmentContentApiDevelopmentCategorizePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof autoCategorizeDevelopmentContentApiDevelopmentCategorizePost>>,
    TError,
    { params: AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof autoCategorizeDevelopmentContentApiDevelopmentCategorizePost>>,
  TError,
  { params: AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams },
  TContext
> => {
  const mutationKey = ['autoCategorizeDevelopmentContentApiDevelopmentCategorizePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof autoCategorizeDevelopmentContentApiDevelopmentCategorizePost>>,
    { params: AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams }
  > = (props) => {
    const { params } = props ?? {};

    return autoCategorizeDevelopmentContentApiDevelopmentCategorizePost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof autoCategorizeDevelopmentContentApiDevelopmentCategorizePost>>
  >;

export type AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostMutationError =
  HTTPValidationError;

/**
 * @summary Auto Categorize Development Content
 */
export const createAutoCategorizeDevelopmentContentApiDevelopmentCategorizePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof autoCategorizeDevelopmentContentApiDevelopmentCategorizePost>>,
      TError,
      { params: AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof autoCategorizeDevelopmentContentApiDevelopmentCategorizePost>>,
  TError,
  { params: AutoCategorizeDevelopmentContentApiDevelopmentCategorizePostParams },
  TContext
> => {
  const mutationOptions =
    getAutoCategorizeDevelopmentContentApiDevelopmentCategorizePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Simple test endpoint
 * @summary Test Endpoint
 */
export const testEndpointApiAiTestGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/ai/test`, method: 'GET', signal });
};

export const getTestEndpointApiAiTestGetQueryKey = () => {
  return [`/api/ai/test`] as const;
};

export const getTestEndpointApiAiTestGetQueryOptions = <
  TData = Awaited<ReturnType<typeof testEndpointApiAiTestGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof testEndpointApiAiTestGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTestEndpointApiAiTestGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof testEndpointApiAiTestGet>>> = ({
    signal,
  }) => testEndpointApiAiTestGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof testEndpointApiAiTestGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TestEndpointApiAiTestGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof testEndpointApiAiTestGet>>
>;
export type TestEndpointApiAiTestGetQueryError = unknown;

/**
 * @summary Test Endpoint
 */

export function createTestEndpointApiAiTestGet<
  TData = Awaited<ReturnType<typeof testEndpointApiAiTestGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof testEndpointApiAiTestGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTestEndpointApiAiTestGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Analyze content using AI with automatic validation.

Returns comprehensive analysis including:
- Title, summary, and detailed summary
- Category and tags
- Key points and entities
- Sentiment and difficulty level
- Reading time estimate
 * @summary Analyze Content
 */
export const analyzeContentApiAiAnalyzePost = (
  contentAnalysisRequest: ContentAnalysisRequest,
  params?: AnalyzeContentApiAiAnalyzePostParams,
  signal?: AbortSignal
) => {
  return customInstance<AnalyzeContentApiAiAnalyzePost200>({
    url: `/api/ai/analyze`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: contentAnalysisRequest,
    params,
    signal,
  });
};

export const getAnalyzeContentApiAiAnalyzePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof analyzeContentApiAiAnalyzePost>>,
    TError,
    { data: ContentAnalysisRequest; params?: AnalyzeContentApiAiAnalyzePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof analyzeContentApiAiAnalyzePost>>,
  TError,
  { data: ContentAnalysisRequest; params?: AnalyzeContentApiAiAnalyzePostParams },
  TContext
> => {
  const mutationKey = ['analyzeContentApiAiAnalyzePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof analyzeContentApiAiAnalyzePost>>,
    { data: ContentAnalysisRequest; params?: AnalyzeContentApiAiAnalyzePostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return analyzeContentApiAiAnalyzePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AnalyzeContentApiAiAnalyzePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof analyzeContentApiAiAnalyzePost>>
>;
export type AnalyzeContentApiAiAnalyzePostMutationBody = ContentAnalysisRequest;
export type AnalyzeContentApiAiAnalyzePostMutationError = HTTPValidationError;

/**
 * @summary Analyze Content
 */
export const createAnalyzeContentApiAiAnalyzePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof analyzeContentApiAiAnalyzePost>>,
      TError,
      { data: ContentAnalysisRequest; params?: AnalyzeContentApiAiAnalyzePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof analyzeContentApiAiAnalyzePost>>,
  TError,
  { data: ContentAnalysisRequest; params?: AnalyzeContentApiAiAnalyzePostParams },
  TContext
> => {
  const mutationOptions = getAnalyzeContentApiAiAnalyzePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generate tags for content with automatic validation.

Returns list of lowercase, deduplicated tags.
 * @summary Generate Tags
 */
export const generateTagsApiAiTagsPost = (
  tagGenerationRequest: TagGenerationRequest,
  params?: GenerateTagsApiAiTagsPostParams,
  signal?: AbortSignal
) => {
  return customInstance<string[]>({
    url: `/api/ai/tags`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tagGenerationRequest,
    params,
    signal,
  });
};

export const getGenerateTagsApiAiTagsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof generateTagsApiAiTagsPost>>,
    TError,
    { data: TagGenerationRequest; params?: GenerateTagsApiAiTagsPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof generateTagsApiAiTagsPost>>,
  TError,
  { data: TagGenerationRequest; params?: GenerateTagsApiAiTagsPostParams },
  TContext
> => {
  const mutationKey = ['generateTagsApiAiTagsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generateTagsApiAiTagsPost>>,
    { data: TagGenerationRequest; params?: GenerateTagsApiAiTagsPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return generateTagsApiAiTagsPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenerateTagsApiAiTagsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generateTagsApiAiTagsPost>>
>;
export type GenerateTagsApiAiTagsPostMutationBody = TagGenerationRequest;
export type GenerateTagsApiAiTagsPostMutationError = HTTPValidationError;

/**
 * @summary Generate Tags
 */
export const createGenerateTagsApiAiTagsPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof generateTagsApiAiTagsPost>>,
      TError,
      { data: TagGenerationRequest; params?: GenerateTagsApiAiTagsPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof generateTagsApiAiTagsPost>>,
  TError,
  { data: TagGenerationRequest; params?: GenerateTagsApiAiTagsPostParams },
  TContext
> => {
  const mutationOptions = getGenerateTagsApiAiTagsPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generate summary of content.

Summary types:
- brief: 50-300 characters
- detailed: 100-1000 characters
- key_points: 3-5 bullet points
 * @summary Generate Summary
 */
export const generateSummaryApiAiSummaryPost = (
  summaryGenerationRequest: SummaryGenerationRequest,
  params?: GenerateSummaryApiAiSummaryPostParams,
  signal?: AbortSignal
) => {
  return customInstance<GenerateSummaryApiAiSummaryPost200>({
    url: `/api/ai/summary`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: summaryGenerationRequest,
    params,
    signal,
  });
};

export const getGenerateSummaryApiAiSummaryPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof generateSummaryApiAiSummaryPost>>,
    TError,
    { data: SummaryGenerationRequest; params?: GenerateSummaryApiAiSummaryPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof generateSummaryApiAiSummaryPost>>,
  TError,
  { data: SummaryGenerationRequest; params?: GenerateSummaryApiAiSummaryPostParams },
  TContext
> => {
  const mutationKey = ['generateSummaryApiAiSummaryPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generateSummaryApiAiSummaryPost>>,
    { data: SummaryGenerationRequest; params?: GenerateSummaryApiAiSummaryPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return generateSummaryApiAiSummaryPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenerateSummaryApiAiSummaryPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generateSummaryApiAiSummaryPost>>
>;
export type GenerateSummaryApiAiSummaryPostMutationBody = SummaryGenerationRequest;
export type GenerateSummaryApiAiSummaryPostMutationError = HTTPValidationError;

/**
 * @summary Generate Summary
 */
export const createGenerateSummaryApiAiSummaryPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof generateSummaryApiAiSummaryPost>>,
      TError,
      { data: SummaryGenerationRequest; params?: GenerateSummaryApiAiSummaryPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof generateSummaryApiAiSummaryPost>>,
  TError,
  { data: SummaryGenerationRequest; params?: GenerateSummaryApiAiSummaryPostParams },
  TContext
> => {
  const mutationOptions = getGenerateSummaryApiAiSummaryPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Transcribe audio using whisper.cpp.

Priority options:
- speed: Uses tiny model for fastest results
- balanced: Uses base model (default)
- accuracy: Uses small model for best accuracy
 * @summary Transcribe Audio
 */
export const transcribeAudioApiAiTranscribePost = (
  transcriptionRequest: TranscriptionRequest,
  params?: TranscribeAudioApiAiTranscribePostParams,
  signal?: AbortSignal
) => {
  return customInstance<TranscribeAudioApiAiTranscribePost200>({
    url: `/api/ai/transcribe`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: transcriptionRequest,
    params,
    signal,
  });
};

export const getTranscribeAudioApiAiTranscribePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof transcribeAudioApiAiTranscribePost>>,
    TError,
    { data: TranscriptionRequest; params?: TranscribeAudioApiAiTranscribePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof transcribeAudioApiAiTranscribePost>>,
  TError,
  { data: TranscriptionRequest; params?: TranscribeAudioApiAiTranscribePostParams },
  TContext
> => {
  const mutationKey = ['transcribeAudioApiAiTranscribePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transcribeAudioApiAiTranscribePost>>,
    { data: TranscriptionRequest; params?: TranscribeAudioApiAiTranscribePostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return transcribeAudioApiAiTranscribePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type TranscribeAudioApiAiTranscribePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof transcribeAudioApiAiTranscribePost>>
>;
export type TranscribeAudioApiAiTranscribePostMutationBody = TranscriptionRequest;
export type TranscribeAudioApiAiTranscribePostMutationError = HTTPValidationError;

/**
 * @summary Transcribe Audio
 */
export const createTranscribeAudioApiAiTranscribePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof transcribeAudioApiAiTranscribePost>>,
      TError,
      { data: TranscriptionRequest; params?: TranscribeAudioApiAiTranscribePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof transcribeAudioApiAiTranscribePost>>,
  TError,
  { data: TranscriptionRequest; params?: TranscribeAudioApiAiTranscribePostParams },
  TContext
> => {
  const mutationOptions = getTranscribeAudioApiAiTranscribePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get information about available transcription models.
 * @summary Get Available Models
 */
export const getAvailableModelsApiAiModelsGet = (
  params?: GetAvailableModelsApiAiModelsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetAvailableModelsApiAiModelsGet200>({
    url: `/api/ai/models`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetAvailableModelsApiAiModelsGetQueryKey = (
  params?: GetAvailableModelsApiAiModelsGetParams
) => {
  return [`/api/ai/models`, ...(params ? [params] : [])] as const;
};

export const getGetAvailableModelsApiAiModelsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAvailableModelsApiAiModelsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAvailableModelsApiAiModelsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>> = ({
    signal,
  }) => getAvailableModelsApiAiModelsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAvailableModelsApiAiModelsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>
>;
export type GetAvailableModelsApiAiModelsGetQueryError = HTTPValidationError;

/**
 * @summary Get Available Models
 */

export function createGetAvailableModelsApiAiModelsGet<
  TData = Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetAvailableModelsApiAiModelsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getAvailableModelsApiAiModelsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAvailableModelsApiAiModelsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get AI validation service status.
 * @summary Get Validation Status
 */
export const getValidationStatusApiAiValidationStatusGet = (
  params?: GetValidationStatusApiAiValidationStatusGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetValidationStatusApiAiValidationStatusGet200>({
    url: `/api/ai/validation/status`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetValidationStatusApiAiValidationStatusGetQueryKey = (
  params?: GetValidationStatusApiAiValidationStatusGetParams
) => {
  return [`/api/ai/validation/status`, ...(params ? [params] : [])] as const;
};

export const getGetValidationStatusApiAiValidationStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GetValidationStatusApiAiValidationStatusGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetValidationStatusApiAiValidationStatusGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>
  > = ({ signal }) => getValidationStatusApiAiValidationStatusGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetValidationStatusApiAiValidationStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>
>;
export type GetValidationStatusApiAiValidationStatusGetQueryError = HTTPValidationError;

/**
 * @summary Get Validation Status
 */

export function createGetValidationStatusApiAiValidationStatusGet<
  TData = Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GetValidationStatusApiAiValidationStatusGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getValidationStatusApiAiValidationStatusGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetValidationStatusApiAiValidationStatusGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ingest a document into the RAG system.

Documents are processed, chunked, embedded, and stored for retrieval.
 * @summary Ingest Document
 */
export const ingestDocumentApiRagIngestPost = (
  documentIngestionRequest: DocumentIngestionRequest,
  params?: IngestDocumentApiRagIngestPostParams,
  signal?: AbortSignal
) => {
  return customInstance<IngestDocumentApiRagIngestPost200>({
    url: `/api/rag/ingest`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: documentIngestionRequest,
    params,
    signal,
  });
};

export const getIngestDocumentApiRagIngestPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof ingestDocumentApiRagIngestPost>>,
    TError,
    { data: DocumentIngestionRequest; params?: IngestDocumentApiRagIngestPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof ingestDocumentApiRagIngestPost>>,
  TError,
  { data: DocumentIngestionRequest; params?: IngestDocumentApiRagIngestPostParams },
  TContext
> => {
  const mutationKey = ['ingestDocumentApiRagIngestPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ingestDocumentApiRagIngestPost>>,
    { data: DocumentIngestionRequest; params?: IngestDocumentApiRagIngestPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return ingestDocumentApiRagIngestPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type IngestDocumentApiRagIngestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof ingestDocumentApiRagIngestPost>>
>;
export type IngestDocumentApiRagIngestPostMutationBody = DocumentIngestionRequest;
export type IngestDocumentApiRagIngestPostMutationError = HTTPValidationError;

/**
 * @summary Ingest Document
 */
export const createIngestDocumentApiRagIngestPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof ingestDocumentApiRagIngestPost>>,
      TError,
      { data: DocumentIngestionRequest; params?: IngestDocumentApiRagIngestPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof ingestDocumentApiRagIngestPost>>,
  TError,
  { data: DocumentIngestionRequest; params?: IngestDocumentApiRagIngestPostParams },
  TContext
> => {
  const mutationOptions = getIngestDocumentApiRagIngestPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Ingest multiple documents in batch.

More efficient than individual ingestion for large datasets.
 * @summary Ingest Batch
 */
export const ingestBatchApiRagIngestBatchPost = (
  batchIngestionRequest: BatchIngestionRequest,
  params?: IngestBatchApiRagIngestBatchPostParams,
  signal?: AbortSignal
) => {
  return customInstance<IngestBatchApiRagIngestBatchPost200>({
    url: `/api/rag/ingest/batch`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: batchIngestionRequest,
    params,
    signal,
  });
};

export const getIngestBatchApiRagIngestBatchPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof ingestBatchApiRagIngestBatchPost>>,
    TError,
    { data: BatchIngestionRequest; params?: IngestBatchApiRagIngestBatchPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof ingestBatchApiRagIngestBatchPost>>,
  TError,
  { data: BatchIngestionRequest; params?: IngestBatchApiRagIngestBatchPostParams },
  TContext
> => {
  const mutationKey = ['ingestBatchApiRagIngestBatchPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ingestBatchApiRagIngestBatchPost>>,
    { data: BatchIngestionRequest; params?: IngestBatchApiRagIngestBatchPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return ingestBatchApiRagIngestBatchPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type IngestBatchApiRagIngestBatchPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof ingestBatchApiRagIngestBatchPost>>
>;
export type IngestBatchApiRagIngestBatchPostMutationBody = BatchIngestionRequest;
export type IngestBatchApiRagIngestBatchPostMutationError = HTTPValidationError;

/**
 * @summary Ingest Batch
 */
export const createIngestBatchApiRagIngestBatchPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof ingestBatchApiRagIngestBatchPost>>,
      TError,
      { data: BatchIngestionRequest; params?: IngestBatchApiRagIngestBatchPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof ingestBatchApiRagIngestBatchPost>>,
  TError,
  { data: BatchIngestionRequest; params?: IngestBatchApiRagIngestBatchPostParams },
  TContext
> => {
  const mutationOptions = getIngestBatchApiRagIngestBatchPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Query the RAG system with a question.

Returns an AI-generated answer based on the knowledge base,
along with source documents used to generate the answer.
 * @summary Query Rag
 */
export const queryRagApiRagQueryPost = (
  rAGQueryRequest: RAGQueryRequest,
  params?: QueryRagApiRagQueryPostParams,
  signal?: AbortSignal
) => {
  return customInstance<QueryRagApiRagQueryPost200>({
    url: `/api/rag/query`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: rAGQueryRequest,
    params,
    signal,
  });
};

export const getQueryRagApiRagQueryPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryRagApiRagQueryPost>>,
    TError,
    { data: RAGQueryRequest; params?: QueryRagApiRagQueryPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryRagApiRagQueryPost>>,
  TError,
  { data: RAGQueryRequest; params?: QueryRagApiRagQueryPostParams },
  TContext
> => {
  const mutationKey = ['queryRagApiRagQueryPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryRagApiRagQueryPost>>,
    { data: RAGQueryRequest; params?: QueryRagApiRagQueryPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return queryRagApiRagQueryPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryRagApiRagQueryPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryRagApiRagQueryPost>>
>;
export type QueryRagApiRagQueryPostMutationBody = RAGQueryRequest;
export type QueryRagApiRagQueryPostMutationError = HTTPValidationError;

/**
 * @summary Query Rag
 */
export const createQueryRagApiRagQueryPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryRagApiRagQueryPost>>,
      TError,
      { data: RAGQueryRequest; params?: QueryRagApiRagQueryPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof queryRagApiRagQueryPost>>,
  TError,
  { data: RAGQueryRequest; params?: QueryRagApiRagQueryPostParams },
  TContext
> => {
  const mutationOptions = getQueryRagApiRagQueryPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Perform hybrid search combining keyword and semantic search.

Weights can be adjusted to favor keyword matching or semantic similarity.
 * @summary Hybrid Search
 */
export const hybridSearchApiRagSearchHybridPost = (
  hybridSearchRequest: HybridSearchRequest,
  params?: HybridSearchApiRagSearchHybridPostParams,
  signal?: AbortSignal
) => {
  return customInstance<HybridSearchApiRagSearchHybridPost200>({
    url: `/api/rag/search/hybrid`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: hybridSearchRequest,
    params,
    signal,
  });
};

export const getHybridSearchApiRagSearchHybridPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof hybridSearchApiRagSearchHybridPost>>,
    TError,
    { data: HybridSearchRequest; params?: HybridSearchApiRagSearchHybridPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof hybridSearchApiRagSearchHybridPost>>,
  TError,
  { data: HybridSearchRequest; params?: HybridSearchApiRagSearchHybridPostParams },
  TContext
> => {
  const mutationKey = ['hybridSearchApiRagSearchHybridPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof hybridSearchApiRagSearchHybridPost>>,
    { data: HybridSearchRequest; params?: HybridSearchApiRagSearchHybridPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return hybridSearchApiRagSearchHybridPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type HybridSearchApiRagSearchHybridPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof hybridSearchApiRagSearchHybridPost>>
>;
export type HybridSearchApiRagSearchHybridPostMutationBody = HybridSearchRequest;
export type HybridSearchApiRagSearchHybridPostMutationError = HTTPValidationError;

/**
 * @summary Hybrid Search
 */
export const createHybridSearchApiRagSearchHybridPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof hybridSearchApiRagSearchHybridPost>>,
      TError,
      { data: HybridSearchRequest; params?: HybridSearchApiRagSearchHybridPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof hybridSearchApiRagSearchHybridPost>>,
  TError,
  { data: HybridSearchRequest; params?: HybridSearchApiRagSearchHybridPostParams },
  TContext
> => {
  const mutationOptions = getHybridSearchApiRagSearchHybridPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Update an existing document in the RAG system.
 * @summary Update Document
 */
export const updateDocumentApiRagDocumentsDocumentIdPut = (
  documentId: string,
  documentUpdateRequest: DocumentUpdateRequest,
  params?: UpdateDocumentApiRagDocumentsDocumentIdPutParams
) => {
  return customInstance<UpdateDocumentApiRagDocumentsDocumentIdPut200>({
    url: `/api/rag/documents/${documentId}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: documentUpdateRequest,
    params,
  });
};

export const getUpdateDocumentApiRagDocumentsDocumentIdPutMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof updateDocumentApiRagDocumentsDocumentIdPut>>,
    TError,
    {
      documentId: string;
      data: DocumentUpdateRequest;
      params?: UpdateDocumentApiRagDocumentsDocumentIdPutParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof updateDocumentApiRagDocumentsDocumentIdPut>>,
  TError,
  {
    documentId: string;
    data: DocumentUpdateRequest;
    params?: UpdateDocumentApiRagDocumentsDocumentIdPutParams;
  },
  TContext
> => {
  const mutationKey = ['updateDocumentApiRagDocumentsDocumentIdPut'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDocumentApiRagDocumentsDocumentIdPut>>,
    {
      documentId: string;
      data: DocumentUpdateRequest;
      params?: UpdateDocumentApiRagDocumentsDocumentIdPutParams;
    }
  > = (props) => {
    const { documentId, data, params } = props ?? {};

    return updateDocumentApiRagDocumentsDocumentIdPut(documentId, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDocumentApiRagDocumentsDocumentIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDocumentApiRagDocumentsDocumentIdPut>>
>;
export type UpdateDocumentApiRagDocumentsDocumentIdPutMutationBody = DocumentUpdateRequest;
export type UpdateDocumentApiRagDocumentsDocumentIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Document
 */
export const createUpdateDocumentApiRagDocumentsDocumentIdPut = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof updateDocumentApiRagDocumentsDocumentIdPut>>,
      TError,
      {
        documentId: string;
        data: DocumentUpdateRequest;
        params?: UpdateDocumentApiRagDocumentsDocumentIdPutParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof updateDocumentApiRagDocumentsDocumentIdPut>>,
  TError,
  {
    documentId: string;
    data: DocumentUpdateRequest;
    params?: UpdateDocumentApiRagDocumentsDocumentIdPutParams;
  },
  TContext
> => {
  const mutationOptions = getUpdateDocumentApiRagDocumentsDocumentIdPutMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Delete a document from the RAG system.
 * @summary Delete Document
 */
export const deleteDocumentApiRagDocumentsDocumentIdDelete = (
  documentId: string,
  params?: DeleteDocumentApiRagDocumentsDocumentIdDeleteParams
) => {
  return customInstance<DeleteDocumentApiRagDocumentsDocumentIdDelete200>({
    url: `/api/rag/documents/${documentId}`,
    method: 'DELETE',
    params,
  });
};

export const getDeleteDocumentApiRagDocumentsDocumentIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof deleteDocumentApiRagDocumentsDocumentIdDelete>>,
    TError,
    { documentId: string; params?: DeleteDocumentApiRagDocumentsDocumentIdDeleteParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof deleteDocumentApiRagDocumentsDocumentIdDelete>>,
  TError,
  { documentId: string; params?: DeleteDocumentApiRagDocumentsDocumentIdDeleteParams },
  TContext
> => {
  const mutationKey = ['deleteDocumentApiRagDocumentsDocumentIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDocumentApiRagDocumentsDocumentIdDelete>>,
    { documentId: string; params?: DeleteDocumentApiRagDocumentsDocumentIdDeleteParams }
  > = (props) => {
    const { documentId, params } = props ?? {};

    return deleteDocumentApiRagDocumentsDocumentIdDelete(documentId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDocumentApiRagDocumentsDocumentIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDocumentApiRagDocumentsDocumentIdDelete>>
>;

export type DeleteDocumentApiRagDocumentsDocumentIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Document
 */
export const createDeleteDocumentApiRagDocumentsDocumentIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof deleteDocumentApiRagDocumentsDocumentIdDelete>>,
      TError,
      { documentId: string; params?: DeleteDocumentApiRagDocumentsDocumentIdDeleteParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof deleteDocumentApiRagDocumentsDocumentIdDelete>>,
  TError,
  { documentId: string; params?: DeleteDocumentApiRagDocumentsDocumentIdDeleteParams },
  TContext
> => {
  const mutationOptions = getDeleteDocumentApiRagDocumentsDocumentIdDeleteMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get RAG system statistics.
 * @summary Get Rag Stats
 */
export const getRagStatsApiRagStatsGet = (
  params?: GetRagStatsApiRagStatsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetRagStatsApiRagStatsGet200>({
    url: `/api/rag/stats`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetRagStatsApiRagStatsGetQueryKey = (params?: GetRagStatsApiRagStatsGetParams) => {
  return [`/api/rag/stats`, ...(params ? [params] : [])] as const;
};

export const getGetRagStatsApiRagStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRagStatsApiRagStatsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRagStatsApiRagStatsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>> = ({
    signal,
  }) => getRagStatsApiRagStatsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRagStatsApiRagStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>
>;
export type GetRagStatsApiRagStatsGetQueryError = HTTPValidationError;

/**
 * @summary Get Rag Stats
 */

export function createGetRagStatsApiRagStatsGet<
  TData = Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRagStatsApiRagStatsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getRagStatsApiRagStatsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRagStatsApiRagStatsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Export the entire knowledge base.
 * @summary Export Knowledge Base
 */
export const exportKnowledgeBaseApiRagExportGet = (
  params?: ExportKnowledgeBaseApiRagExportGetParams,
  signal?: AbortSignal
) => {
  return customInstance<ExportKnowledgeBaseApiRagExportGet200>({
    url: `/api/rag/export`,
    method: 'GET',
    params,
    signal,
  });
};

export const getExportKnowledgeBaseApiRagExportGetQueryKey = (
  params?: ExportKnowledgeBaseApiRagExportGetParams
) => {
  return [`/api/rag/export`, ...(params ? [params] : [])] as const;
};

export const getExportKnowledgeBaseApiRagExportGetQueryOptions = <
  TData = Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>,
  TError = HTTPValidationError,
>(
  params?: ExportKnowledgeBaseApiRagExportGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExportKnowledgeBaseApiRagExportGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>> = ({
    signal,
  }) => exportKnowledgeBaseApiRagExportGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExportKnowledgeBaseApiRagExportGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>
>;
export type ExportKnowledgeBaseApiRagExportGetQueryError = HTTPValidationError;

/**
 * @summary Export Knowledge Base
 */

export function createExportKnowledgeBaseApiRagExportGet<
  TData = Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>,
  TError = HTTPValidationError,
>(
  params?: ExportKnowledgeBaseApiRagExportGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof exportKnowledgeBaseApiRagExportGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getExportKnowledgeBaseApiRagExportGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ingest a file (PDF, DOCX, TXT) into the RAG system.

The file will be processed and its content extracted before ingestion.
 * @summary Ingest File
 */
export const ingestFileApiRagIngestFilePost = (
  bodyIngestFileApiRagIngestFilePost: BodyIngestFileApiRagIngestFilePost,
  params?: IngestFileApiRagIngestFilePostParams,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`file`, bodyIngestFileApiRagIngestFilePost.file);

  return customInstance<IngestFileApiRagIngestFilePost200>({
    url: `/api/rag/ingest/file`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    params,
    signal,
  });
};

export const getIngestFileApiRagIngestFilePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof ingestFileApiRagIngestFilePost>>,
    TError,
    { data: BodyIngestFileApiRagIngestFilePost; params?: IngestFileApiRagIngestFilePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof ingestFileApiRagIngestFilePost>>,
  TError,
  { data: BodyIngestFileApiRagIngestFilePost; params?: IngestFileApiRagIngestFilePostParams },
  TContext
> => {
  const mutationKey = ['ingestFileApiRagIngestFilePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof ingestFileApiRagIngestFilePost>>,
    { data: BodyIngestFileApiRagIngestFilePost; params?: IngestFileApiRagIngestFilePostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return ingestFileApiRagIngestFilePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type IngestFileApiRagIngestFilePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof ingestFileApiRagIngestFilePost>>
>;
export type IngestFileApiRagIngestFilePostMutationBody = BodyIngestFileApiRagIngestFilePost;
export type IngestFileApiRagIngestFilePostMutationError = HTTPValidationError;

/**
 * @summary Ingest File
 */
export const createIngestFileApiRagIngestFilePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof ingestFileApiRagIngestFilePost>>,
      TError,
      { data: BodyIngestFileApiRagIngestFilePost; params?: IngestFileApiRagIngestFilePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof ingestFileApiRagIngestFilePost>>,
  TError,
  { data: BodyIngestFileApiRagIngestFilePost; params?: IngestFileApiRagIngestFilePostParams },
  TContext
> => {
  const mutationOptions = getIngestFileApiRagIngestFilePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Scrape a single URL with advanced options.

Supports JavaScript rendering, content extraction, and various output formats.
 * @summary Scrape Url
 */
export const scrapeUrlApiFirecrawlScrapePost = (
  scrapingRequest: ScrapingRequest,
  params?: ScrapeUrlApiFirecrawlScrapePostParams,
  signal?: AbortSignal
) => {
  return customInstance<ScrapeUrlApiFirecrawlScrapePost200>({
    url: `/api/firecrawl/scrape`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: scrapingRequest,
    params,
    signal,
  });
};

export const getScrapeUrlApiFirecrawlScrapePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scrapeUrlApiFirecrawlScrapePost>>,
    TError,
    { data: ScrapingRequest; params?: ScrapeUrlApiFirecrawlScrapePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scrapeUrlApiFirecrawlScrapePost>>,
  TError,
  { data: ScrapingRequest; params?: ScrapeUrlApiFirecrawlScrapePostParams },
  TContext
> => {
  const mutationKey = ['scrapeUrlApiFirecrawlScrapePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scrapeUrlApiFirecrawlScrapePost>>,
    { data: ScrapingRequest; params?: ScrapeUrlApiFirecrawlScrapePostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return scrapeUrlApiFirecrawlScrapePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScrapeUrlApiFirecrawlScrapePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof scrapeUrlApiFirecrawlScrapePost>>
>;
export type ScrapeUrlApiFirecrawlScrapePostMutationBody = ScrapingRequest;
export type ScrapeUrlApiFirecrawlScrapePostMutationError = HTTPValidationError;

/**
 * @summary Scrape Url
 */
export const createScrapeUrlApiFirecrawlScrapePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scrapeUrlApiFirecrawlScrapePost>>,
      TError,
      { data: ScrapingRequest; params?: ScrapeUrlApiFirecrawlScrapePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scrapeUrlApiFirecrawlScrapePost>>,
  TError,
  { data: ScrapingRequest; params?: ScrapeUrlApiFirecrawlScrapePostParams },
  TContext
> => {
  const mutationOptions = getScrapeUrlApiFirecrawlScrapePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Crawl an entire website with configurable limits.

Returns job ID for async crawling status tracking.
 * @summary Crawl Website
 */
export const crawlWebsiteApiFirecrawlCrawlPost = (
  crawlingRequest: CrawlingRequest,
  params?: CrawlWebsiteApiFirecrawlCrawlPostParams,
  signal?: AbortSignal
) => {
  return customInstance<CrawlWebsiteApiFirecrawlCrawlPost200>({
    url: `/api/firecrawl/crawl`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: crawlingRequest,
    params,
    signal,
  });
};

export const getCrawlWebsiteApiFirecrawlCrawlPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof crawlWebsiteApiFirecrawlCrawlPost>>,
    TError,
    { data: CrawlingRequest; params?: CrawlWebsiteApiFirecrawlCrawlPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof crawlWebsiteApiFirecrawlCrawlPost>>,
  TError,
  { data: CrawlingRequest; params?: CrawlWebsiteApiFirecrawlCrawlPostParams },
  TContext
> => {
  const mutationKey = ['crawlWebsiteApiFirecrawlCrawlPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof crawlWebsiteApiFirecrawlCrawlPost>>,
    { data: CrawlingRequest; params?: CrawlWebsiteApiFirecrawlCrawlPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return crawlWebsiteApiFirecrawlCrawlPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CrawlWebsiteApiFirecrawlCrawlPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof crawlWebsiteApiFirecrawlCrawlPost>>
>;
export type CrawlWebsiteApiFirecrawlCrawlPostMutationBody = CrawlingRequest;
export type CrawlWebsiteApiFirecrawlCrawlPostMutationError = HTTPValidationError;

/**
 * @summary Crawl Website
 */
export const createCrawlWebsiteApiFirecrawlCrawlPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof crawlWebsiteApiFirecrawlCrawlPost>>,
      TError,
      { data: CrawlingRequest; params?: CrawlWebsiteApiFirecrawlCrawlPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof crawlWebsiteApiFirecrawlCrawlPost>>,
  TError,
  { data: CrawlingRequest; params?: CrawlWebsiteApiFirecrawlCrawlPostParams },
  TContext
> => {
  const mutationOptions = getCrawlWebsiteApiFirecrawlCrawlPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Extract structured data from a webpage using AI.

Provide a JSON schema to define the data structure you want to extract.
 * @summary Extract Structured Data
 */
export const extractStructuredDataApiFirecrawlExtractPost = (
  structuredExtractionRequest: StructuredExtractionRequest,
  params?: ExtractStructuredDataApiFirecrawlExtractPostParams,
  signal?: AbortSignal
) => {
  return customInstance<ExtractStructuredDataApiFirecrawlExtractPost200>({
    url: `/api/firecrawl/extract`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: structuredExtractionRequest,
    params,
    signal,
  });
};

export const getExtractStructuredDataApiFirecrawlExtractPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof extractStructuredDataApiFirecrawlExtractPost>>,
    TError,
    {
      data: StructuredExtractionRequest;
      params?: ExtractStructuredDataApiFirecrawlExtractPostParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof extractStructuredDataApiFirecrawlExtractPost>>,
  TError,
  {
    data: StructuredExtractionRequest;
    params?: ExtractStructuredDataApiFirecrawlExtractPostParams;
  },
  TContext
> => {
  const mutationKey = ['extractStructuredDataApiFirecrawlExtractPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof extractStructuredDataApiFirecrawlExtractPost>>,
    {
      data: StructuredExtractionRequest;
      params?: ExtractStructuredDataApiFirecrawlExtractPostParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return extractStructuredDataApiFirecrawlExtractPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExtractStructuredDataApiFirecrawlExtractPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof extractStructuredDataApiFirecrawlExtractPost>>
>;
export type ExtractStructuredDataApiFirecrawlExtractPostMutationBody = StructuredExtractionRequest;
export type ExtractStructuredDataApiFirecrawlExtractPostMutationError = HTTPValidationError;

/**
 * @summary Extract Structured Data
 */
export const createExtractStructuredDataApiFirecrawlExtractPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof extractStructuredDataApiFirecrawlExtractPost>>,
      TError,
      {
        data: StructuredExtractionRequest;
        params?: ExtractStructuredDataApiFirecrawlExtractPostParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof extractStructuredDataApiFirecrawlExtractPost>>,
  TError,
  {
    data: StructuredExtractionRequest;
    params?: ExtractStructuredDataApiFirecrawlExtractPostParams;
  },
  TContext
> => {
  const mutationOptions = getExtractStructuredDataApiFirecrawlExtractPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Scrape multiple URLs concurrently.

Limited to 20 URLs per request to prevent abuse.
 * @summary Batch Scrape
 */
export const batchScrapeApiFirecrawlBatchScrapePost = (
  batchScrapingRequest: BatchScrapingRequest,
  params?: BatchScrapeApiFirecrawlBatchScrapePostParams,
  signal?: AbortSignal
) => {
  return customInstance<BatchScrapeApiFirecrawlBatchScrapePost200>({
    url: `/api/firecrawl/batch-scrape`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: batchScrapingRequest,
    params,
    signal,
  });
};

export const getBatchScrapeApiFirecrawlBatchScrapePostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof batchScrapeApiFirecrawlBatchScrapePost>>,
    TError,
    { data: BatchScrapingRequest; params?: BatchScrapeApiFirecrawlBatchScrapePostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof batchScrapeApiFirecrawlBatchScrapePost>>,
  TError,
  { data: BatchScrapingRequest; params?: BatchScrapeApiFirecrawlBatchScrapePostParams },
  TContext
> => {
  const mutationKey = ['batchScrapeApiFirecrawlBatchScrapePost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof batchScrapeApiFirecrawlBatchScrapePost>>,
    { data: BatchScrapingRequest; params?: BatchScrapeApiFirecrawlBatchScrapePostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return batchScrapeApiFirecrawlBatchScrapePost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type BatchScrapeApiFirecrawlBatchScrapePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof batchScrapeApiFirecrawlBatchScrapePost>>
>;
export type BatchScrapeApiFirecrawlBatchScrapePostMutationBody = BatchScrapingRequest;
export type BatchScrapeApiFirecrawlBatchScrapePostMutationError = HTTPValidationError;

/**
 * @summary Batch Scrape
 */
export const createBatchScrapeApiFirecrawlBatchScrapePost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof batchScrapeApiFirecrawlBatchScrapePost>>,
      TError,
      { data: BatchScrapingRequest; params?: BatchScrapeApiFirecrawlBatchScrapePostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof batchScrapeApiFirecrawlBatchScrapePost>>,
  TError,
  { data: BatchScrapingRequest; params?: BatchScrapeApiFirecrawlBatchScrapePostParams },
  TContext
> => {
  const mutationOptions = getBatchScrapeApiFirecrawlBatchScrapePostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get the status of a crawl job.
 * @summary Get Crawl Status
 */
export const getCrawlStatusApiFirecrawlJobJobIdGet = (
  jobId: string,
  params?: GetCrawlStatusApiFirecrawlJobJobIdGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetCrawlStatusApiFirecrawlJobJobIdGet200>({
    url: `/api/firecrawl/job/${jobId}`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetCrawlStatusApiFirecrawlJobJobIdGetQueryKey = (
  jobId: string,
  params?: GetCrawlStatusApiFirecrawlJobJobIdGetParams
) => {
  return [`/api/firecrawl/job/${jobId}`, ...(params ? [params] : [])] as const;
};

export const getGetCrawlStatusApiFirecrawlJobJobIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>,
  TError = HTTPValidationError,
>(
  jobId: string,
  params?: GetCrawlStatusApiFirecrawlJobJobIdGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCrawlStatusApiFirecrawlJobJobIdGetQueryKey(jobId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>
  > = ({ signal }) => getCrawlStatusApiFirecrawlJobJobIdGet(jobId, params, signal);

  return { queryKey, queryFn, enabled: !!jobId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCrawlStatusApiFirecrawlJobJobIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>
>;
export type GetCrawlStatusApiFirecrawlJobJobIdGetQueryError = HTTPValidationError;

/**
 * @summary Get Crawl Status
 */

export function createGetCrawlStatusApiFirecrawlJobJobIdGet<
  TData = Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>,
  TError = HTTPValidationError,
>(
  jobId: string,
  params?: GetCrawlStatusApiFirecrawlJobJobIdGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getCrawlStatusApiFirecrawlJobJobIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCrawlStatusApiFirecrawlJobJobIdGetQueryOptions(jobId, params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get Firecrawl service status and configuration.
 * @summary Get Service Status
 */
export const getServiceStatusApiFirecrawlStatusGet = (
  params?: GetServiceStatusApiFirecrawlStatusGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetServiceStatusApiFirecrawlStatusGet200>({
    url: `/api/firecrawl/status`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetServiceStatusApiFirecrawlStatusGetQueryKey = (
  params?: GetServiceStatusApiFirecrawlStatusGetParams
) => {
  return [`/api/firecrawl/status`, ...(params ? [params] : [])] as const;
};

export const getGetServiceStatusApiFirecrawlStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GetServiceStatusApiFirecrawlStatusGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetServiceStatusApiFirecrawlStatusGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>
  > = ({ signal }) => getServiceStatusApiFirecrawlStatusGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetServiceStatusApiFirecrawlStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>
>;
export type GetServiceStatusApiFirecrawlStatusGetQueryError = HTTPValidationError;

/**
 * @summary Get Service Status
 */

export function createGetServiceStatusApiFirecrawlStatusGet<
  TData = Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>,
  TError = HTTPValidationError,
>(
  params?: GetServiceStatusApiFirecrawlStatusGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof getServiceStatusApiFirecrawlStatusGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetServiceStatusApiFirecrawlStatusGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Perform enhanced search with the new embedding architecture.

Supports semantic, keyword, and hybrid search modes with automatic
deduplication based on content fingerprints.
 * @summary Enhanced Search
 */
export const enhancedSearchApiSearchPost = (
  searchRequest: SearchRequest,
  params?: EnhancedSearchApiSearchPostParams,
  signal?: AbortSignal
) => {
  return customInstance<EnhancedSearchApiSearchPost200>({
    url: `/api/search/`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: searchRequest,
    params,
    signal,
  });
};

export const getEnhancedSearchApiSearchPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof enhancedSearchApiSearchPost>>,
    TError,
    { data: SearchRequest; params?: EnhancedSearchApiSearchPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof enhancedSearchApiSearchPost>>,
  TError,
  { data: SearchRequest; params?: EnhancedSearchApiSearchPostParams },
  TContext
> => {
  const mutationKey = ['enhancedSearchApiSearchPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof enhancedSearchApiSearchPost>>,
    { data: SearchRequest; params?: EnhancedSearchApiSearchPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return enhancedSearchApiSearchPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type EnhancedSearchApiSearchPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof enhancedSearchApiSearchPost>>
>;
export type EnhancedSearchApiSearchPostMutationBody = SearchRequest;
export type EnhancedSearchApiSearchPostMutationError = HTTPValidationError;

/**
 * @summary Enhanced Search
 */
export const createEnhancedSearchApiSearchPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof enhancedSearchApiSearchPost>>,
      TError,
      { data: SearchRequest; params?: EnhancedSearchApiSearchPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof enhancedSearchApiSearchPost>>,
  TError,
  { data: SearchRequest; params?: EnhancedSearchApiSearchPostParams },
  TContext
> => {
  const mutationOptions = getEnhancedSearchApiSearchPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * GET endpoint for keyword search (convenience method).
 * @summary Keyword Search Get
 */
export const keywordSearchGetApiSearchKeywordGet = (
  params: KeywordSearchGetApiSearchKeywordGetParams,
  signal?: AbortSignal
) => {
  return customInstance<KeywordSearchGetApiSearchKeywordGet200>({
    url: `/api/search/keyword`,
    method: 'GET',
    params,
    signal,
  });
};

export const getKeywordSearchGetApiSearchKeywordGetQueryKey = (
  params: KeywordSearchGetApiSearchKeywordGetParams
) => {
  return [`/api/search/keyword`, ...(params ? [params] : [])] as const;
};

export const getKeywordSearchGetApiSearchKeywordGetQueryOptions = <
  TData = Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>,
  TError = HTTPValidationError,
>(
  params: KeywordSearchGetApiSearchKeywordGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getKeywordSearchGetApiSearchKeywordGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>> = ({
    signal,
  }) => keywordSearchGetApiSearchKeywordGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KeywordSearchGetApiSearchKeywordGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>
>;
export type KeywordSearchGetApiSearchKeywordGetQueryError = HTTPValidationError;

/**
 * @summary Keyword Search Get
 */

export function createKeywordSearchGetApiSearchKeywordGet<
  TData = Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>,
  TError = HTTPValidationError,
>(
  params: KeywordSearchGetApiSearchKeywordGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof keywordSearchGetApiSearchKeywordGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getKeywordSearchGetApiSearchKeywordGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Find duplicate content using content fingerprint.
 * @summary Find Duplicates
 */
export const findDuplicatesApiSearchDuplicatesPost = (
  duplicateSearchRequest: DuplicateSearchRequest,
  params?: FindDuplicatesApiSearchDuplicatesPostParams,
  signal?: AbortSignal
) => {
  return customInstance<FindDuplicatesApiSearchDuplicatesPost200>({
    url: `/api/search/duplicates`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: duplicateSearchRequest,
    params,
    signal,
  });
};

export const getFindDuplicatesApiSearchDuplicatesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof findDuplicatesApiSearchDuplicatesPost>>,
    TError,
    { data: DuplicateSearchRequest; params?: FindDuplicatesApiSearchDuplicatesPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof findDuplicatesApiSearchDuplicatesPost>>,
  TError,
  { data: DuplicateSearchRequest; params?: FindDuplicatesApiSearchDuplicatesPostParams },
  TContext
> => {
  const mutationKey = ['findDuplicatesApiSearchDuplicatesPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof findDuplicatesApiSearchDuplicatesPost>>,
    { data: DuplicateSearchRequest; params?: FindDuplicatesApiSearchDuplicatesPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return findDuplicatesApiSearchDuplicatesPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type FindDuplicatesApiSearchDuplicatesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof findDuplicatesApiSearchDuplicatesPost>>
>;
export type FindDuplicatesApiSearchDuplicatesPostMutationBody = DuplicateSearchRequest;
export type FindDuplicatesApiSearchDuplicatesPostMutationError = HTTPValidationError;

/**
 * @summary Find Duplicates
 */
export const createFindDuplicatesApiSearchDuplicatesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof findDuplicatesApiSearchDuplicatesPost>>,
      TError,
      { data: DuplicateSearchRequest; params?: FindDuplicatesApiSearchDuplicatesPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof findDuplicatesApiSearchDuplicatesPost>>,
  TError,
  { data: DuplicateSearchRequest; params?: FindDuplicatesApiSearchDuplicatesPostParams },
  TContext
> => {
  const mutationOptions = getFindDuplicatesApiSearchDuplicatesPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Find items similar to a given item using embedding similarity.
 * @summary Find Similar Items
 */
export const findSimilarItemsApiSearchSimilarPost = (
  similarItemsRequest: SimilarItemsRequest,
  params?: FindSimilarItemsApiSearchSimilarPostParams,
  signal?: AbortSignal
) => {
  return customInstance<FindSimilarItemsApiSearchSimilarPost200>({
    url: `/api/search/similar`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: similarItemsRequest,
    params,
    signal,
  });
};

export const getFindSimilarItemsApiSearchSimilarPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarPost>>,
    TError,
    { data: SimilarItemsRequest; params?: FindSimilarItemsApiSearchSimilarPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarPost>>,
  TError,
  { data: SimilarItemsRequest; params?: FindSimilarItemsApiSearchSimilarPostParams },
  TContext
> => {
  const mutationKey = ['findSimilarItemsApiSearchSimilarPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarPost>>,
    { data: SimilarItemsRequest; params?: FindSimilarItemsApiSearchSimilarPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return findSimilarItemsApiSearchSimilarPost(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type FindSimilarItemsApiSearchSimilarPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarPost>>
>;
export type FindSimilarItemsApiSearchSimilarPostMutationBody = SimilarItemsRequest;
export type FindSimilarItemsApiSearchSimilarPostMutationError = HTTPValidationError;

/**
 * @summary Find Similar Items
 */
export const createFindSimilarItemsApiSearchSimilarPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarPost>>,
      TError,
      { data: SimilarItemsRequest; params?: FindSimilarItemsApiSearchSimilarPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof findSimilarItemsApiSearchSimilarPost>>,
  TError,
  { data: SimilarItemsRequest; params?: FindSimilarItemsApiSearchSimilarPostParams },
  TContext
> => {
  const mutationOptions = getFindSimilarItemsApiSearchSimilarPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get statistics about the search system.
 * @summary Get Search Stats
 */
export const getSearchStatsApiSearchStatsGet = (
  params?: GetSearchStatsApiSearchStatsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<GetSearchStatsApiSearchStatsGet200>({
    url: `/api/search/stats`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetSearchStatsApiSearchStatsGetQueryKey = (
  params?: GetSearchStatsApiSearchStatsGetParams
) => {
  return [`/api/search/stats`, ...(params ? [params] : [])] as const;
};

export const getGetSearchStatsApiSearchStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSearchStatsApiSearchStatsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSearchStatsApiSearchStatsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>> = ({
    signal,
  }) => getSearchStatsApiSearchStatsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSearchStatsApiSearchStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>
>;
export type GetSearchStatsApiSearchStatsGetQueryError = HTTPValidationError;

/**
 * @summary Get Search Stats
 */

export function createGetSearchStatsApiSearchStatsGet<
  TData = Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>,
  TError = HTTPValidationError,
>(
  params?: GetSearchStatsApiSearchStatsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getSearchStatsApiSearchStatsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSearchStatsApiSearchStatsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Migrate legacy embeddings from items.embedding to embeddings table.
 * @summary Migrate Legacy Embeddings
 */
export const migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost = (
  params?: MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams,
  signal?: AbortSignal
) => {
  return customInstance<MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost200>({
    url: `/api/search/migrate-embeddings`,
    method: 'POST',
    params,
    signal,
  });
};

export const getMigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost>>,
    TError,
    { params?: MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost>>,
  TError,
  { params?: MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams },
  TContext
> => {
  const mutationKey = ['migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost>>,
    { params?: MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost>>
>;

export type MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostMutationError =
  HTTPValidationError;

/**
 * @summary Migrate Legacy Embeddings
 */
export const createMigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost>>,
      TError,
      { params?: MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof migrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPost>>,
  TError,
  { params?: MigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostParams },
  TContext
> => {
  const mutationOptions =
    getMigrateLegacyEmbeddingsApiSearchMigrateEmbeddingsPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Update embeddings for all items using content fingerprint change detection.
 * @summary Update All Embeddings
 */
export const updateAllEmbeddingsApiSearchUpdateEmbeddingsPost = (
  params?: UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams,
  signal?: AbortSignal
) => {
  return customInstance<UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPost200>({
    url: `/api/search/update-embeddings`,
    method: 'POST',
    params,
    signal,
  });
};

export const getUpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof updateAllEmbeddingsApiSearchUpdateEmbeddingsPost>>,
    TError,
    { params?: UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof updateAllEmbeddingsApiSearchUpdateEmbeddingsPost>>,
  TError,
  { params?: UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams },
  TContext
> => {
  const mutationKey = ['updateAllEmbeddingsApiSearchUpdateEmbeddingsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAllEmbeddingsApiSearchUpdateEmbeddingsPost>>,
    { params?: UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return updateAllEmbeddingsApiSearchUpdateEmbeddingsPost(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAllEmbeddingsApiSearchUpdateEmbeddingsPost>>
>;

export type UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostMutationError = HTTPValidationError;

/**
 * @summary Update All Embeddings
 */
export const createUpdateAllEmbeddingsApiSearchUpdateEmbeddingsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof updateAllEmbeddingsApiSearchUpdateEmbeddingsPost>>,
      TError,
      { params?: UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof updateAllEmbeddingsApiSearchUpdateEmbeddingsPost>>,
  TError,
  { params?: UpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostParams },
  TContext
> => {
  const mutationOptions =
    getUpdateAllEmbeddingsApiSearchUpdateEmbeddingsPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * List items with standard pagination
 * @summary List Items
 */
export const listItemsApiV2ItemsGet = (
  params?: ListItemsApiV2ItemsGetParams,
  signal?: AbortSignal
) => {
  return customInstance<unknown>({ url: `/api/v2/items`, method: 'GET', params, signal });
};

export const getListItemsApiV2ItemsGetQueryKey = (params?: ListItemsApiV2ItemsGetParams) => {
  return [`/api/v2/items`, ...(params ? [params] : [])] as const;
};

export const getListItemsApiV2ItemsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListItemsApiV2ItemsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListItemsApiV2ItemsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>> = ({ signal }) =>
    listItemsApiV2ItemsGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListItemsApiV2ItemsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>
>;
export type ListItemsApiV2ItemsGetQueryError = HTTPValidationError;

/**
 * @summary List Items
 */

export function createListItemsApiV2ItemsGet<
  TData = Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListItemsApiV2ItemsGetParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof listItemsApiV2ItemsGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListItemsApiV2ItemsGetQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new item with standard response
 * @summary Create Item
 */
export const createItemApiV2ItemsPost = (itemCreate: ItemCreate, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/api/v2/items`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: itemCreate,
    signal,
  });
};

export const getCreateItemApiV2ItemsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof createItemApiV2ItemsPost>>,
    TError,
    { data: ItemCreate },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof createItemApiV2ItemsPost>>,
  TError,
  { data: ItemCreate },
  TContext
> => {
  const mutationKey = ['createItemApiV2ItemsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createItemApiV2ItemsPost>>,
    { data: ItemCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createItemApiV2ItemsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateItemApiV2ItemsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createItemApiV2ItemsPost>>
>;
export type CreateItemApiV2ItemsPostMutationBody = ItemCreate;
export type CreateItemApiV2ItemsPostMutationError = HTTPValidationError;

/**
 * @summary Create Item
 */
export const createCreateItemApiV2ItemsPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof createItemApiV2ItemsPost>>,
      TError,
      { data: ItemCreate },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof createItemApiV2ItemsPost>>,
  TError,
  { data: ItemCreate },
  TContext
> => {
  const mutationOptions = getCreateItemApiV2ItemsPostMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Get a specific item with standard response
 * @summary Get Item
 */
export const getItemApiV2ItemsItemIdGet = (itemId: string, signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/api/v2/items/${itemId}`, method: 'GET', signal });
};

export const getGetItemApiV2ItemsItemIdGetQueryKey = (itemId: string) => {
  return [`/api/v2/items/${itemId}`] as const;
};

export const getGetItemApiV2ItemsItemIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemApiV2ItemsItemIdGetQueryKey(itemId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>> = ({
    signal,
  }) => getItemApiV2ItemsItemIdGet(itemId, signal);

  return { queryKey, queryFn, enabled: !!itemId, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetItemApiV2ItemsItemIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>
>;
export type GetItemApiV2ItemsItemIdGetQueryError = HTTPValidationError;

/**
 * @summary Get Item
 */

export function createGetItemApiV2ItemsItemIdGet<
  TData = Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>,
  TError = HTTPValidationError,
>(
  itemId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof getItemApiV2ItemsItemIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetItemApiV2ItemsItemIdGetQueryOptions(itemId, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update an item with standard response
 * @summary Update Item
 */
export const updateItemApiV2ItemsItemIdPatch = (itemId: string, itemUpdate: ItemUpdate) => {
  return customInstance<unknown>({
    url: `/api/v2/items/${itemId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: itemUpdate,
  });
};

export const getUpdateItemApiV2ItemsItemIdPatchMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof updateItemApiV2ItemsItemIdPatch>>,
    TError,
    { itemId: string; data: ItemUpdate },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof updateItemApiV2ItemsItemIdPatch>>,
  TError,
  { itemId: string; data: ItemUpdate },
  TContext
> => {
  const mutationKey = ['updateItemApiV2ItemsItemIdPatch'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateItemApiV2ItemsItemIdPatch>>,
    { itemId: string; data: ItemUpdate }
  > = (props) => {
    const { itemId, data } = props ?? {};

    return updateItemApiV2ItemsItemIdPatch(itemId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateItemApiV2ItemsItemIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateItemApiV2ItemsItemIdPatch>>
>;
export type UpdateItemApiV2ItemsItemIdPatchMutationBody = ItemUpdate;
export type UpdateItemApiV2ItemsItemIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Item
 */
export const createUpdateItemApiV2ItemsItemIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof updateItemApiV2ItemsItemIdPatch>>,
      TError,
      { itemId: string; data: ItemUpdate },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof updateItemApiV2ItemsItemIdPatch>>,
  TError,
  { itemId: string; data: ItemUpdate },
  TContext
> => {
  const mutationOptions = getUpdateItemApiV2ItemsItemIdPatchMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Delete an item with standard response
 * @summary Delete Item
 */
export const deleteItemApiV2ItemsItemIdDelete = (itemId: string) => {
  return customInstance<unknown>({ url: `/api/v2/items/${itemId}`, method: 'DELETE' });
};

export const getDeleteItemApiV2ItemsItemIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof deleteItemApiV2ItemsItemIdDelete>>,
    TError,
    { itemId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof deleteItemApiV2ItemsItemIdDelete>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationKey = ['deleteItemApiV2ItemsItemIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItemApiV2ItemsItemIdDelete>>,
    { itemId: string }
  > = (props) => {
    const { itemId } = props ?? {};

    return deleteItemApiV2ItemsItemIdDelete(itemId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteItemApiV2ItemsItemIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteItemApiV2ItemsItemIdDelete>>
>;

export type DeleteItemApiV2ItemsItemIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Item
 */
export const createDeleteItemApiV2ItemsItemIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof deleteItemApiV2ItemsItemIdDelete>>,
      TError,
      { itemId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof deleteItemApiV2ItemsItemIdDelete>>,
  TError,
  { itemId: string },
  TContext
> => {
  const mutationOptions = getDeleteItemApiV2ItemsItemIdDeleteMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * @summary Health Check
 */
export const healthCheckHealthGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/health`, method: 'GET', signal });
};

export const getHealthCheckHealthGetQueryKey = () => {
  return [`/health`] as const;
};

export const getHealthCheckHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    CreateQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) =>
    healthCheckHealthGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckHealthGet>>
>;
export type HealthCheckHealthGetQueryError = unknown;

/**
 * @summary Health Check
 */

export function createHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthCheckHealthGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Read Root
 */
export const readRootGet = (signal?: AbortSignal) => {
  return customInstance<unknown>({ url: `/`, method: 'GET', signal });
};

export const getReadRootGetQueryKey = () => {
  return [`/`] as const;
};

export const getReadRootGetQueryOptions = <
  TData = Awaited<ReturnType<typeof readRootGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof readRootGet>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReadRootGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readRootGet>>> = ({ signal }) =>
    readRootGet(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof readRootGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadRootGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRootGet>>>;
export type ReadRootGetQueryError = unknown;

/**
 * @summary Read Root
 */

export function createReadRootGet<
  TData = Awaited<ReturnType<typeof readRootGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof readRootGet>>, TError, TData>>;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getReadRootGetQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
